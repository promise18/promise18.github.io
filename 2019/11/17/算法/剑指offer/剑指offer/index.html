<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法,剑指offer,">










<meta name="description" content="01、二维数组中的查找（一般）题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345matrix = [	[1,2,3]	[4,5,6]	[7,8,9]] 解题思路从右上角或左下角开始找，逐行排除，或者用二分法查找。 代码实现12345678">
<meta name="keywords" content="算法,剑指offer">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer">
<meta property="og:url" content="http://yoursite.com/2019/11/17/算法/剑指offer/剑指offer/index.html">
<meta property="og:site_name" content="HyCoder&#39;s Blog">
<meta property="og:description" content="01、二维数组中的查找（一般）题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345matrix = [	[1,2,3]	[4,5,6]	[7,8,9]] 解题思路从右上角或左下角开始找，逐行排除，或者用二分法查找。 代码实现12345678">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/11/17/算法/剑指offer/剑指offer/2018121200474149.png">
<meta property="og:image" content="http://yoursite.com/2019/11/17/算法/剑指offer/剑指offer/20190719192858379.png">
<meta property="og:image" content="http://yoursite.com/2019/11/17/算法/剑指offer/剑指offer/20181212233050681.png">
<meta property="og:image" content="http://yoursite.com/2019/11/17/算法/剑指offer/剑指offer/124213_1560686577137_ba355101-4a93-4c71-94fb-1da83639727b.jpg">
<meta property="og:image" content="http://yoursite.com/2019/11/17/算法/剑指offer/剑指offer/124213_1560686577152_af1d1166-63af-47b6-9aa3-2bf2bd37bd03.jpg">
<meta property="og:image" content="http://yoursite.com/2019/11/17/算法/剑指offer/剑指offer/20160525171645123">
<meta property="og:image" content="http://yoursite.com/2019/11/17/算法/剑指offer/剑指offer/20181215213441301.png">
<meta property="og:updated_time" content="2019-11-18T12:54:42.323Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer">
<meta name="twitter:description" content="01、二维数组中的查找（一般）题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345matrix = [	[1,2,3]	[4,5,6]	[7,8,9]] 解题思路从右上角或左下角开始找，逐行排除，或者用二分法查找。 代码实现12345678">
<meta name="twitter:image" content="http://yoursite.com/2019/11/17/算法/剑指offer/剑指offer/2018121200474149.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/17/算法/剑指offer/剑指offer/">





  <title>剑指offer | HyCoder's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HyCoder's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/17/算法/剑指offer/剑指offer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HyCoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HyCoder's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">剑指offer</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-17T15:30:57+08:00">
                2019-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/剑指offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/17/算法/剑指offer/剑指offer/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/11/17/算法/剑指offer/剑指offer/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/11/17/算法/剑指offer/剑指offer/" class="leancloud_visitors" data-flag-title="剑指offer">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="01_u3001_u4E8C_u7EF4_u6570_u7EC4_u4E2D_u7684_u67E5_u627E_uFF08_u4E00_u822C_uFF09"><a href="#01_u3001_u4E8C_u7EF4_u6570_u7EC4_u4E2D_u7684_u67E5_u627E_uFF08_u4E00_u822C_uFF09" class="headerlink" title="01、二维数组中的查找（一般）"></a>01、二维数组中的查找（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0"><a href="#u9898_u76EE_u63CF_u8FF0" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">	[1,2,3]</span><br><span class="line">	[4,5,6]</span><br><span class="line">	[7,8,9]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="u89E3_u9898_u601D_u8DEF"><a href="#u89E3_u9898_u601D_u8DEF" class="headerlink" title="解题思路"></a>解题思路</h3><p>从右上角或左下角开始找，逐行排除，或者用二分法查找。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0"><a href="#u4EE3_u7801_u5B9E_u73B0" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[][] array, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> row =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col =array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(row&lt;array.length &amp;&amp; col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[row][col] == number)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[row][col] &gt; number)&#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：array.length返回的二维数组的行的长度，array[i].length返回的是第i行的长度。</p>
<h2 id="02_u3001_u66FF_u6362_u7A7A_u683C_uFF08_u770B_u4E00_u4E0B_u5C31_u4F1A_uFF09"><a href="#02_u3001_u66FF_u6362_u7A7A_u683C_uFF08_u770B_u4E00_u4E0B_u5C31_u4F1A_uFF09" class="headerlink" title="02、替换空格（看一下就会）"></a>02、替换空格（看一下就会）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-1"><a href="#u9898_u76EE_u63CF_u8FF0-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-1"><a href="#u89E3_u9898_u601D_u8DEF-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用StringBuffer或者StringBuilder从前往后复制字符串。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-1"><a href="#u4EE3_u7801_u5B9E_u73B0-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replace</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现代码</span></span><br><span class="line">    <span class="keyword">if</span>(text == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;text.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(String.valueOf(text.charAt(i)).equals(<span class="string">" "</span>))&#123;</span><br><span class="line">            sb.append(<span class="string">"%20"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(text.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="03_u3001_u4ECE_u5C3E_u5230_u5934_u6253_u5370_u94FE_u8868_uFF08_u4E00_u822C_uFF09"><a href="#03_u3001_u4ECE_u5C3E_u5230_u5934_u6253_u5370_u94FE_u8868_uFF08_u4E00_u822C_uFF09" class="headerlink" title="03、从尾到头打印链表（一般）"></a>03、从尾到头打印链表（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-2"><a href="#u9898_u76EE_u63CF_u8FF0-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-2"><a href="#u89E3_u9898_u601D_u8DEF-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法一：利用栈来实现；、</p>
<p>方法二：利用三个指针把链表反转。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-2"><a href="#u4EE3_u7801_u5B9E_u73B0-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个链表</span></span><br><span class="line"><span class="keyword">public</span> Class ListNode&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next =<span class="keyword">null</span>;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val =val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        list.add(stack.pop().values);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：(将链表翻转)</p>
<h2 id="04_u3001_u91CD_u5EFA_u4E8C_u53C9_u6811_uFF08_u4E00_u822C_uFF09"><a href="#04_u3001_u91CD_u5EFA_u4E8C_u53C9_u6811_uFF08_u4E00_u822C_uFF09" class="headerlink" title="04、重建二叉树（一般）"></a>04、重建二叉树（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-3"><a href="#u9898_u76EE_u63CF_u8FF0-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-3"><a href="#u89E3_u9898_u601D_u8DEF-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>先找根节点，再递归构建。</p>
<p>前序遍历的第一个节点就是树的根节点，所以我们先根据前序遍历序列的第一个数字创建根结点，接下来在中序遍历序列中找到根结点的位置，根节点的左边就是左子树，右边就是右子树，这样就能确定左、右子树结点的数量。在前序遍历和中序遍历的序列中划分了左、右子树结点的值之后，就可以递归地去分别构建它的左右子树。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-3"><a href="#u4EE3_u7801_u5B9E_u73B0-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一颗二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre.length != in.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[<span class="number">0</span>] == in[i]) &#123;</span><br><span class="line">            root.left = reConstructBinaryTree(</span><br><span class="line">                Arrays.copyOfRange(pre,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,i));</span><br><span class="line">            root.right = reConstructBinaryTree(     Arrays.copyOfRange(pre,i+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,i+<span class="number">1</span>,in.length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="05_u3001_u7528_u4E24_u4E2A_u6808_u5B9E_u73B0_u961F_u5217_28_u7B80_u5355_29"><a href="#05_u3001_u7528_u4E24_u4E2A_u6808_u5B9E_u73B0_u961F_u5217_28_u7B80_u5355_29" class="headerlink" title="05、用两个栈实现队列(简单)"></a>05、用两个栈实现队列(简单)</h2><h3 id="u9898_u76EE_u63CF_u8FF0-4"><a href="#u9898_u76EE_u63CF_u8FF0-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-4"><a href="#u89E3_u9898_u601D_u8DEF-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>两个栈 stack1 和 stack2:</p>
<ul>
<li>push 动作都在 stack1 中进行，</li>
<li>pop 动作在 stack2 中进行。当 stack2 不为空时，直接 pop，当 stack2 为空时，先把 stack1 中的元素 pop 出来，push 到 stack2 中，再从 stack2 中 pop 元素。</li>
</ul>
<h3 id="u5B9E_u73B0_u4EE3_u7801"><a href="#u5B9E_u73B0_u4EE3_u7801" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="06_u3001_u65CB_u8F6C_u6570_u7EC4_u7684_u6700_u5C0F_u6570_u5B57_uFF08_u540CLeetCode153_uFF0C154_uFF0C_u4E00_u822C_uFF09"><a href="#06_u3001_u65CB_u8F6C_u6570_u7EC4_u7684_u6700_u5C0F_u6570_u5B57_uFF08_u540CLeetCode153_uFF0C154_uFF0C_u4E00_u822C_uFF09" class="headerlink" title="06、旋转数组的最小数字（同LeetCode153，154，一般）"></a>06、旋转数组的最小数字（同LeetCode153，154，一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-5"><a href="#u9898_u76EE_u63CF_u8FF0-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-5"><a href="#u89E3_u9898_u601D_u8DEF-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用二分查找</p>
<p>注意：</p>
<ul>
<li>循环条件为：left&lt;right</li>
<li>right=mid;left=mid+1。若high=mid-1会产生错误。</li>
<li>return left,right都可以</li>
</ul>
<h3 id="u4EE3_u7801_u5B9E_u73B0-4"><a href="#u4EE3_u7801_u5B9E_u73B0-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>[] ints)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = ints.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid =left +(right -left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(ints[mid]&gt;ints[right])&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ints[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="07_u3001_u6590_u6CE2_u90A3_u5951_u6570_u5217_uFF08_u7B80_u5355_uFF09"><a href="#07_u3001_u6590_u6CE2_u90A3_u5951_u6570_u5217_uFF08_u7B80_u5355_uFF09" class="headerlink" title="07、斐波那契数列（简单）"></a>07、斐波那契数列（简单）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-6"><a href="#u9898_u76EE_u63CF_u8FF0-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p>
<blockquote>
<p>公式:<br>f(n) = n, n &lt;= 1<br>f(n) = f(n-1) + f(n-2), n &gt; 1</p>
<p>f~0~=0，f~1~=1，f~2~=1，f~3~=2，f~4~=3,…,fn=f~n-2~+f~n-1~</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-6"><a href="#u89E3_u9898_u601D_u8DEF-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>递归，效率太低</li>
<li>动态规划</li>
</ul>
<h3 id="u4EE3_u7801_u5B9E_u73B0-5"><a href="#u4EE3_u7801_u5B9E_u73B0-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>||N==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        <span class="keyword">int</span> fn1=<span class="number">0</span>,fn2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            result = fn1+fn2;</span><br><span class="line">            fn1=fn2;</span><br><span class="line">            fn2=result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u884D_u751F_u9898"><a href="#u884D_u751F_u9898" class="headerlink" title="衍生题"></a>衍生题</h3><ul>
<li>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。（代码与上面相同）</li>
<li>一只青蛙一次可以跳上1级台阶，也可以跳上2级……<strong>它也可以跳上n级。</strong>求该青蛙跳上一个n级的台阶总共有多少种跳法。（2^(n-1)^）</li>
<li>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？(斐波那契思想)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (N-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            i = j - i;</span><br><span class="line">            j = i + j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11_u3001_u4E8C_u8FDB_u5236_u4E2D1_u7684_u4E2A_u6570_uFF08_u4E00_u822C_uFF09"><a href="#11_u3001_u4E8C_u8FDB_u5236_u4E2D1_u7684_u4E2A_u6570_uFF08_u4E00_u822C_uFF09" class="headerlink" title="11、二进制中1的个数（一般）"></a>11、二进制中1的个数（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-7"><a href="#u9898_u76EE_u63CF_u8FF0-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-7"><a href="#u89E3_u9898_u601D_u8DEF-7" class="headerlink" title="解题思路"></a>解题思路</h3><p><a href="E:\Notes\什么是原码，反码、补码.md" target="_blank" rel="noopener">参考：原码，反码，补码</a></p>
<p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。<br>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-6"><a href="#u4EE3_u7801_u5B9E_u73B0-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            count+=<span class="number">1</span>;</span><br><span class="line">            n&amp;=(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12_u3001_u6570_u503C_u7684_u6574_u6570_u6B21_u65B9_uFF08_u6CA1_u505A_uFF09"><a href="#12_u3001_u6570_u503C_u7684_u6574_u6570_u6B21_u65B9_uFF08_u6CA1_u505A_uFF09" class="headerlink" title="12、数值的整数次方（没做）"></a>12、数值的整数次方（没做）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-8"><a href="#u9898_u76EE_u63CF_u8FF0-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。不得使用库函数，不需要考虑大数问题。</p>
<h2 id="13_u3001_u8C03_u6574_u6570_u7EC4_u987A_u5E8F_u4F7F_u5947_u6570_u4F4D_u4E8E_u5076_u6570_u524D_u9762_uFF08_u5F85_u5B8C_u5584_uFF09"><a href="#13_u3001_u8C03_u6574_u6570_u7EC4_u987A_u5E8F_u4F7F_u5947_u6570_u4F4D_u4E8E_u5076_u6570_u524D_u9762_uFF08_u5F85_u5B8C_u5584_uFF09" class="headerlink" title="13、调整数组顺序使奇数位于偶数前面（待完善）"></a>13、调整数组顺序使奇数位于偶数前面（待完善）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-9"><a href="#u9898_u76EE_u63CF_u8FF0-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-8"><a href="#u89E3_u9898_u601D_u8DEF-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法一：</p>
<p>使用额外空间，复制原数组，找到放置偶数的起始下标。</p>
<p>方法二：</p>
<p>使用双指针。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-7"><a href="#u4EE3_u7801_u5B9E_u73B0-7" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>方法一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderArray</span><span class="params">(<span class="keyword">int</span>[] ints)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oddnums=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:ints) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">            oddnums++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] copy = ints.clone();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=oddnums;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:copy)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">            ints[i] = num;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ints[j]=num;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14_u3001_u94FE_u8868_u4E2D_u5012_u6570_u7B2Ck_u4E2A_u8282_u70B9_28_u4E00_u822C_29"><a href="#14_u3001_u94FE_u8868_u4E2D_u5012_u6570_u7B2Ck_u4E2A_u8282_u70B9_28_u4E00_u822C_29" class="headerlink" title="14、链表中倒数第k个节点(一般)"></a>14、链表中倒数第k个节点(一般)</h2><h3 id="u9898_u76EE_u63CF_u8FF0-10"><a href="#u9898_u76EE_u63CF_u8FF0-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-9"><a href="#u89E3_u9898_u601D_u8DEF-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>倒数第k个结点，即第n-k+1结点</p>
<p>==快慢指针==，定义两个指针，定义两个指针slow和fast，使他们都指向第一个结点。到第 n-k+1 个结点则需要移动 n-k次。</p>
<p>此时，fast移动n次会指向空。先让fast移动 k 次，还剩 n-k 次指向空。</p>
<p>这时，slow与fast同步移动，当fast指空时，node移动了 n-k 次，刚好到第 n-k+1 个结点</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-8"><a href="#u4EE3_u7801_u5B9E_u73B0-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>||k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15_u3001_u53CD_u8F6C_u94FE_u8868_uFF08_u4E00_u822C_uFF09"><a href="#15_u3001_u53CD_u8F6C_u94FE_u8868_uFF08_u4E00_u822C_uFF09" class="headerlink" title="15、反转链表（一般）"></a>15、反转链表（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-11"><a href="#u9898_u76EE_u63CF_u8FF0-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-10"><a href="#u89E3_u9898_u601D_u8DEF-10" class="headerlink" title="解题思路"></a>解题思路</h3><p>设置两个指针，pre为当前节点的前一个节点，next为当前节点的下一个节点</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-9"><a href="#u4EE3_u7801_u5B9E_u73B0-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre =<span class="keyword">null</span>;</span><br><span class="line">        ListNode next =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            next =head.next; <span class="comment">//next为当前节点的下一个结点</span></span><br><span class="line">            head.next=pre; <span class="comment">//将当前结点的下一个节点指向前一个结点,（进行反转）</span></span><br><span class="line">            pre = head; <span class="comment">//pre记录当前结点，即下一个结点的前一个结点</span></span><br><span class="line">            head =next; <span class="comment">//将当前结改为下一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16_u3001_u5408_u5E76_u4E24_u4E2A_u6392_u5E8F_u7684_u94FE_u8868_uFF08_u9012_u5F52_uFF0C_u7B80_u5355_uFF09"><a href="#16_u3001_u5408_u5E76_u4E24_u4E2A_u6392_u5E8F_u7684_u94FE_u8868_uFF08_u9012_u5F52_uFF0C_u7B80_u5355_uFF09" class="headerlink" title="16、合并两个排序的链表（递归，简单）"></a>16、合并两个排序的链表（递归，简单）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-12"><a href="#u9898_u76EE_u63CF_u8FF0-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-11"><a href="#u89E3_u9898_u601D_u8DEF-11" class="headerlink" title="解题思路"></a>解题思路</h3><p>声明一个新链表，不断比较原来两个链表的 val 值，小的插入新链表即可。</p>
<p>递归与非递归求解，小数放在前面。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-10"><a href="#u4EE3_u7801_u5B9E_u73B0-10" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        ListNode mergeNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">            mergeNode =list1;</span><br><span class="line">            mergeNode.next=Merge(list1.next,list2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mergeNode =list2;</span><br><span class="line">            mergeNode.next=Merge(list1,list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>非递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">9999</span>);</span><br><span class="line">    ListNode tmp = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val) &#123;<span class="comment">//比较两个链表当前结点的值，小的先插入新链表</span></span><br><span class="line">            tmp.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//容错，将剩余链表补到新链表结尾，此时能保持单调不减</span></span><br><span class="line">    <span class="keyword">if</span>(list1 != <span class="keyword">null</span>) tmp.next = list1;</span><br><span class="line">    <span class="keyword">if</span>(list2 != <span class="keyword">null</span>) tmp.next = list2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.next;<span class="comment">//记得head为声明的无意义表头，head.next才是新链表的头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17_u3001_u6811_u7684_u5B50_u7ED3_u6784_uFF08_u4E00_u822C_uFF09"><a href="#17_u3001_u6811_u7684_u5B50_u7ED3_u6784_uFF08_u4E00_u822C_uFF09" class="headerlink" title="17、树的子结构（一般）"></a>17、树的子结构（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-13"><a href="#u9898_u76EE_u63CF_u8FF0-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<h3 id="u89E3_u9898_u601D_u8DEF-12"><a href="#u89E3_u9898_u601D_u8DEF-12" class="headerlink" title="解题思路"></a>解题思路</h3><p>设置终止条件进行判断，将B树与A树，A树左子树，A树右子树进行比较，递归进行即可。</p>
<ul>
<li>递归思想，如果根节点相同则递归调用IsSubtree()，如果根节点不相同，则判断<code>root1</code>的左子树和<code>roo2</code>是否相同，再判断右子树和<code>root2</code>是否相同;</li>
<li>注意节点为空的条件，<code>HasSubTree</code>中，只要有树为空就返回<code>false</code>; <code>IsSubtree</code>中，要先判断<code>root2</code>，如果<code>root2</code>为空，则说明第二棵树遍历完了，即匹配成功。</li>
</ul>
<h3 id="u5B9E_u73B0_u4EE3_u7801-1"><a href="#u5B9E_u73B0_u4EE3_u7801-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>||root2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubTree(root1,root2)|| <span class="comment">//root2与root1比较</span></span><br><span class="line">            isSubTree(root1.left,root2)||<span class="comment">//root2与root1左子树比较</span></span><br><span class="line">            isSubTree(root1.right,root2);<span class="comment">//root2与root1右比较</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubTree</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//注意！！！，先判断root2是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">            <span class="comment">//当root1.val == root2.val时，继续对root1，root2的左右子树分别递归此方法进行判断，均为true则为子结构</span></span><br><span class="line">            <span class="keyword">return</span> isSubTree(root1.left,root2.left) &amp;&amp; isSubTree(root1.right,root2.right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="18_u3001_u4E8C_u53C9_u6811_u7684_u955C_u50CF_uFF08_u7B80_u5355_uFF09"><a href="#18_u3001_u4E8C_u53C9_u6811_u7684_u955C_u50CF_uFF08_u7B80_u5355_uFF09" class="headerlink" title="18、二叉树的镜像（简单）"></a>18、二叉树的镜像（简单）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-14"><a href="#u9898_u76EE_u63CF_u8FF0-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>输入描述:</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; 二叉树的镜像定义：源二叉树 </span><br><span class="line">&gt;     	    8</span><br><span class="line">&gt;     	   /  \</span><br><span class="line">&gt;     	  6   10</span><br><span class="line">&gt;     	 / \  / \</span><br><span class="line">&gt;     	5  7 9 11</span><br><span class="line">&gt;     	镜像二叉树</span><br><span class="line">&gt;     	    8</span><br><span class="line">&gt;     	   /  \</span><br><span class="line">&gt;     	  10   6</span><br><span class="line">&gt;     	 / \  / \</span><br><span class="line">&gt;     	11 9 7  5</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-13"><a href="#u89E3_u9898_u601D_u8DEF-13" class="headerlink" title="解题思路"></a>解题思路</h3><p>交换每个结点的左右子树，并对该结点的左右子结点分别进行此操作，递归进行即可</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-11"><a href="#u4EE3_u7801_u5B9E_u73B0-11" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        exchange(root);</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        TreeNode temp =root.left;</span><br><span class="line">        root.left =root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19_u3001_u987A_u65F6_u9488_u6253_u5370_u77E9_u9635_uFF08_u7B80_u5355_uFF09"><a href="#19_u3001_u987A_u65F6_u9488_u6253_u5370_u77E9_u9635_uFF08_u7B80_u5355_uFF09" class="headerlink" title="19、顺时针打印矩阵（简单）"></a>19、顺时针打印矩阵（简单）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-15"><a href="#u9898_u76EE_u63CF_u8FF0-15" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-14"><a href="#u89E3_u9898_u601D_u8DEF-14" class="headerlink" title="解题思路"></a>解题思路</h3><p>先得到矩阵的行和列数，然后依次旋转打印数据，一次旋转打印结束后，往对角分别前进和后退一个单位。要注意单行和单列的情况。</p>
<p>定义4个变量，left，right，top，bottom。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-12"><a href="#u4EE3_u7801_u5B9E_u73B0-12" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].length;</span><br><span class="line">        ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>&amp;&amp; col ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> left =<span class="number">0</span>,right=col-<span class="number">1</span>,top=<span class="number">0</span>,bottom = row-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right&amp;&amp;top&lt;=bottom)&#123;</span><br><span class="line">            <span class="comment">//上：从左到右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =left;i&lt;=right;i++)&#123;</span><br><span class="line">                res.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右：从上到下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top+<span class="number">1</span>;i&lt;=bottom;i++)&#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下：从右到左</span></span><br><span class="line">            <span class="keyword">if</span>(top!=bottom)&#123; <span class="comment">// 注意！！！</span></span><br><span class="line">                <span class="comment">//防止单行情况</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i =right-<span class="number">1</span>;i&gt;=left;i--)&#123;</span><br><span class="line">                    res.add(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左：从下到上</span></span><br><span class="line">            <span class="keyword">if</span>(left!=right)&#123;<span class="comment">// 注意！！！</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom-<span class="number">1</span>;i&gt;top;i--)&#123;</span><br><span class="line">                    res.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;right--;top++;bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="20_u3001_u5305_u542Bmin_u51FD_u6570_u7684_u6808_uFF08_u4E00_u822C_uFF09"><a href="#20_u3001_u5305_u542Bmin_u51FD_u6570_u7684_u6808_uFF08_u4E00_u822C_uFF09" class="headerlink" title="20、包含min函数的栈（一般）"></a>20、包含min函数的栈（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-16"><a href="#u9898_u76EE_u63CF_u8FF0-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-15"><a href="#u89E3_u9898_u601D_u8DEF-15" class="headerlink" title="解题思路"></a>解题思路</h3><p>用一个栈stack保存数据，用另外一个栈minStack保存依次入栈最小的数。</p>
<p>==minStack用于存储任一元素入栈时，当前栈内的最小值，与stack同步入栈出栈的，即两个栈内元素数目相同。比如，stack中依次入栈：==<br><code>5, 3, 4, 10, 2, 12, 1, 8</code><br>则minStack依次入栈：<br><code>5, 3, 3，3, 2, 2, 1, 1</code></p>
<p>每次入栈的时候，如果入栈的元素比min中的栈顶元素小或等于则入栈，否则用最小元素入栈。</p>
<h3 id="u5B9E_u73B0_u4EE3_u7801-2"><a href="#u5B9E_u73B0_u4EE3_u7801-2" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack =<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> minValue = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span>(node&lt;minValue)&#123;</span><br><span class="line">            minStack.push(node);</span><br><span class="line">            minValue = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minStack.push(minValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top =stack.peek();</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = minStack.peek();</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="21_u3001_u6808_u7684_u538B_u5165_u3001_u5F39_u51FA_u5E8F_u5217_uFF08_u4E00_u822C_uFF09"><a href="#21_u3001_u6808_u7684_u538B_u5165_u3001_u5F39_u51FA_u5E8F_u5217_uFF08_u4E00_u822C_uFF09" class="headerlink" title="21、栈的压入、弹出序列（一般）"></a>21、栈的压入、弹出序列（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-17"><a href="#u9898_u76EE_u63CF_u8FF0-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h3 id="u89E3_u9898_u601D_u8DEF-16"><a href="#u89E3_u9898_u601D_u8DEF-16" class="headerlink" title="解题思路"></a>解题思路</h3><p>==<strong>模拟堆栈操作的过程，将原数列依次压栈，把栈顶元素与所给出栈队列相比，如果相同则出栈；如果不同则继续压栈，直到原数列中所有数字压栈完毕。</strong>==</p>
<p>最后，检测栈中是否为空，若空，说明出栈队列可由原数列进行栈操作得到。否则，说明出栈队列不能由原数列进行栈操作得到。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-13"><a href="#u4EE3_u7801_u5B9E_u73B0-13" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA==<span class="keyword">null</span> || popA==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack =<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek()==popA[index])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="22_u3001_u4ECE_u4E0A_u5F80_u4E0B_u6253_u5370_u4E8C_u53C9_u6811_uFF08_u4E00_u822C_uFF0CBFS_uFF09"><a href="#22_u3001_u4ECE_u4E0A_u5F80_u4E0B_u6253_u5370_u4E8C_u53C9_u6811_uFF08_u4E00_u822C_uFF0CBFS_uFF09" class="headerlink" title="22、从上往下打印二叉树（一般，BFS）"></a>22、从上往下打印二叉树（一般，BFS）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-18"><a href="#u9898_u76EE_u63CF_u8FF0-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-17"><a href="#u89E3_u9898_u601D_u8DEF-17" class="headerlink" title="解题思路"></a>解题思路</h3><p>==就是二叉树的层次遍历，使用广度优先搜索（BFS）。==借助队列。</p>
<p>使用队列实现，边出队边输入，同时将其左右子节点压入队列。先将根节点加入到队列中，然后遍历队列中的元素，遍历过程中，访问该元素的左右节点，再将左右子节点加入到队列中来。<br>注意<code>Queue</code>创建的方式：<code>Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</code><br>用<code>add</code>将元素添加到队列中，用<code>remove</code>来移除并返回队首元素。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-14"><a href="#u4EE3_u7801_u5B9E_u73B0-14" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; queue =<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            root=queue.remove();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="23_u3001_u4E8C_u53C9_u641C_u7D22_u6811_u7684_u540E_u5E8F_u904D_u5386_u5E8F_u5217_uFF08_u4E00_u822C_uFF09"><a href="#23_u3001_u4E8C_u53C9_u641C_u7D22_u6811_u7684_u540E_u5E8F_u904D_u5386_u5E8F_u5217_uFF08_u4E00_u822C_uFF09" class="headerlink" title="23、二叉搜索树的后序遍历序列（一般）"></a>23、二叉搜索树的后序遍历序列（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-19"><a href="#u9898_u76EE_u63CF_u8FF0-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-18"><a href="#u89E3_u9898_u601D_u8DEF-18" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉搜索树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树（二叉排序树）。即：</p>
<blockquote>
<p>二叉搜索树: 左子树&lt;根&lt; 右子树</p>
</blockquote>
<p>后序遍历：左 -&gt; 右 -&gt; 根。</p>
<p>因此，后序遍历最后一个数为根结点。通过根结点可把后序遍历分为两部分，前半部分为小于根结点的左子树，后半部分为大于根结点的右子树。然后根据此原理，递归对左右子树分别用此方法进行验证即可。</p>
<p>找到最后小于根节点的左结点的位置</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-15"><a href="#u4EE3_u7801_u5B9E_u73B0-15" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> judge(sequence,<span class="number">0</span>,sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span>[] sequence,<span class="keyword">int</span> start,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;=root)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> index =start;<span class="comment">//index记录最后一个小于根节点的左节点的位置</span></span><br><span class="line">        <span class="keyword">while</span>(index&lt;root&amp;&amp;sequence[index]&lt;sequence[root])&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时sequence[index]是第一个比根结点大的值</span></span><br><span class="line">        <span class="comment">//可将sequence[0]~sequence[index-1]认为是左子树，					    //	 sequence[index]~sequence[root-1]认为是右子树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =index;j&lt;root;j++)&#123;</span><br><span class="line">            <span class="comment">//若右子树中存在比根结点小的，则不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&lt;sequence[root])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时分别对根结点的左右子树进行迭代判断，全部为true则是后序遍历</span></span><br><span class="line">        <span class="keyword">return</span> (judge(sequence,start,index-<span class="number">1</span>)&amp;&amp;judge(sequence,index,root-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="24_u3001_u4E8C_u53C9_u6811_u4E2D_u548C_u4E3A_u67D0_u4E00_u503C_u7684_u8DEF_u5F84_28_u96BE_29"><a href="#24_u3001_u4E8C_u53C9_u6811_u4E2D_u548C_u4E3A_u67D0_u4E00_u503C_u7684_u8DEF_u5F84_28_u96BE_29" class="headerlink" title="24、二叉树中和为某一值的路径(难)"></a>24、二叉树中和为某一值的路径(难)</h2><h3 id="u9898_u76EE_u63CF_u8FF0-20"><a href="#u9898_u76EE_u63CF_u8FF0-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<h3 id="u89E3_u9898_u601D_u8DEF-19"><a href="#u89E3_u9898_u601D_u8DEF-19" class="headerlink" title="解题思路"></a>解题思路</h3><p>用<strong>深度优先搜索(DFS)</strong>或(前序遍历)的方式访问到某一结点时，把该结点添加到路径上，并用目标值减去该节点的值。如果该结点为叶结点并且目标值减去该节点的值刚好为0，则当前的路径符合要求，我们把加入res数组中。如果当前结点不是叶结点，则继续访问它的子结点。当前结点访问结束后，递归函数将自动回到它的父结点。</p>
<p>因此我们在函数退出之前要在路径上删除当前结点，以确保返回父结点时路径刚好是从叶结点到父结点的路径。</p>
<p><strong>注意</strong>：路径要求最后到达<strong>叶子结点</strong>。<br>==迭代过程中需把当前值在path中移除以保证路径正确，相当于回退到上一步的路径。==</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-16"><a href="#u4EE3_u7801_u5B9E_u73B0-16" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root ==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        target -=root.val;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(target ==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//已经到达叶子结点且targe正好减完</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            FindPath(root.left,target);</span><br><span class="line">            FindPath(root.right,target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//迭代过程中需把当前值在path中移除以保证路径正确，相当于回退到上一步的路径</span></span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="25_u3001_u590D_u6742_u94FE_u8868_u7684_u590D_u5236_uFF08_u96BE_uFF09"><a href="#25_u3001_u590D_u6742_u94FE_u8868_u7684_u590D_u5236_uFF08_u96BE_uFF09" class="headerlink" title="25、复杂链表的复制（难）"></a>25、复杂链表的复制（难）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-21"><a href="#u9898_u76EE_u63CF_u8FF0-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h3 id="u89E3_u9898_u601D_u8DEF-20"><a href="#u89E3_u9898_u601D_u8DEF-20" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>step1</strong>：在每个结点的后面（或者说每个结点与下一个结点中间）插入<strong>新结点</strong>。该新结点为克隆结点，这么做是为了连接random结点。</p>
<p><strong>step2</strong>：连接random结点。</p>
<p><strong>step3</strong>：拆分链表，下边为原链表，上边为clone链表。</p>
<p><img src="/2019/11/17/算法/剑指offer/剑指offer/2018121200474149.png" alt="img"></p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-17"><a href="#u4EE3_u7801_u5B9E_u73B0-17" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode temp = pHead;</span><br><span class="line">        <span class="comment">//step1：在每个结点的后面（或者说每个结点与下一个结点中间）插入【新结点】</span></span><br><span class="line">		<span class="comment">//该新结点为克隆结点，这么做是为了连接random结点</span></span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(temp.label);</span><br><span class="line">            <span class="comment">//插入clone节点</span></span><br><span class="line">            cloneNode.next=temp.next;</span><br><span class="line">            temp.next=cloneNode;</span><br><span class="line">            <span class="comment">//移除到原链表的下一个节点</span></span><br><span class="line">            temp = cloneNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//step2：连接random结点</span></span><br><span class="line">        temp =pHead;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode cloneNode =temp.next;</span><br><span class="line">            <span class="keyword">if</span>(temp.random!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//tmp.random是原链表的结点，tmp.random.next才是那个结点的clone结点</span></span><br><span class="line">                cloneNode.random = temp.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = cloneNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//step3：拆分链表</span></span><br><span class="line">        temp = pHead;</span><br><span class="line">        RandomListNode cloneHead =temp.next;</span><br><span class="line">        <span class="keyword">while</span>(temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode node =temp.next;</span><br><span class="line">            temp.next = node.next;</span><br><span class="line">            temp=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="26_u3001_u4E8C_u53C9_u641C_u7D22_u6811_u548C_u53CC_u5411_u94FE_u8868_uFF08_u96BE_uFF09"><a href="#26_u3001_u4E8C_u53C9_u641C_u7D22_u6811_u548C_u53CC_u5411_u94FE_u8868_uFF08_u96BE_uFF09" class="headerlink" title="26、二叉搜索树和双向链表（难）"></a>26、二叉搜索树和双向链表（难）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-22"><a href="#u9898_u76EE_u63CF_u8FF0-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-21"><a href="#u89E3_u9898_u601D_u8DEF-21" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于二叉搜索树<strong>左子结点 &lt; 根结点 &lt; 右子结点</strong>的性质，题目实质上是<strong>二叉搜索树</strong>的<strong>中序遍历</strong>，改结点的指针。left代表双向链表的prev指针，right代表next指针。</p>
<p>每次遍历节点的左孩子、右孩子，把左孩子指向转换链表的尾节点，并把末尾指针的右孩子指向自己。右孩子指向节点的右孩子。如果没有右孩子就返回。这一过程可以用递归实现。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-18"><a href="#u4EE3_u7801_u5B9E_u73B0-18" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>; <span class="comment">//记录上一个节点</span></span><br><span class="line">    TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        inOrder(pRootOfTree);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//实质上是中序遍历，改结点的指针。left代表双向链表的pre指针，right代表next</span></span><br><span class="line">	    <span class="comment">//左</span></span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        <span class="comment">//根</span></span><br><span class="line">	    <span class="comment">//改指针的指向（只需与上一个结点相连即可）</span></span><br><span class="line">        node.left= pre;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pre.right=node;<span class="comment">//如果上一个不为null，连此时这个</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;<span class="comment">//将pre移向此时这个结点，为下一次迭代做准备</span></span><br><span class="line">        <span class="keyword">if</span>(head ==<span class="keyword">null</span>) head =node; <span class="comment">//只在第一次找到最小结点时作为头结点</span></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="27_u3001_u5B57_u7B26_u4E32_u7684_u6392_u5217_uFF08_u96BE_uFF0C_u770B_uFF09"><a href="#27_u3001_u5B57_u7B26_u4E32_u7684_u6392_u5217_uFF08_u96BE_uFF0C_u770B_uFF09" class="headerlink" title="27、字符串的排列（难，看）"></a>27、字符串的排列（难，看）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-23"><a href="#u9898_u76EE_u63CF_u8FF0-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串,按<strong>字典序</strong>打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<blockquote>
<p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-22"><a href="#u89E3_u9898_u601D_u8DEF-22" class="headerlink" title="解题思路"></a>解题思路</h3><p>（1） 把字符串分为两部分，一部分是字符串的第一个字符，另一部分是第一个字符以后的所有字符。<br>（2） 求第一个字符后面部分的字符串的全排列<br>（3） 拿第一个字符和它后面的字符逐个交换</p>
<p><img src="/2019/11/17/算法/剑指offer/剑指offer/20190719192858379.png" alt="在这里插入图片描述"></p>
<p><strong>———————————分割线————————————–</strong></p>
<h2 id="28_u3001_u6570_u7EC4_u4E2D_u51FA_u73B0_u6B21_u6570_u8D85_u8FC7_u4E00_u534A_u7684_u6570_u5B57"><a href="#28_u3001_u6570_u7EC4_u4E2D_u51FA_u73B0_u6B21_u6570_u8D85_u8FC7_u4E00_u534A_u7684_u6570_u5B57" class="headerlink" title="28、数组中出现次数超过一半的数字"></a>28、数组中出现次数超过一半的数字</h2><h3 id="u9898_u76EE_u63CF_u8FF0-24"><a href="#u9898_u76EE_u63CF_u8FF0-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-23"><a href="#u89E3_u9898_u601D_u8DEF-23" class="headerlink" title="解题思路"></a>解题思路</h3><p>在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-19"><a href="#u4EE3_u7801_u5B9E_u73B0-19" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==num)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count ==<span class="number">0</span>)&#123;</span><br><span class="line">                num = array[i];</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val:array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val ==num)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count&gt;array.length/<span class="number">2</span>?num:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="29_u3001_u6700_u5C0F_u7684k_u4E2A_u6570_uFF08_u4E00_u822C_uFF0C_u5806_uFF09"><a href="#29_u3001_u6700_u5C0F_u7684k_u4E2A_u6570_uFF08_u4E00_u822C_uFF0C_u5806_uFF09" class="headerlink" title="29、最小的k个数（一般，堆）"></a>29、最小的k个数（一般，堆）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-25"><a href="#u9898_u76EE_u63CF_u8FF0-25" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-24"><a href="#u89E3_u9898_u601D_u8DEF-24" class="headerlink" title="解题思路"></a>解题思路</h3><p>用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，新数入堆。</p>
<p><a href="https://www.nowcoder.com/questionTerminal/6a296eb82cf844ca8539b57c23e6e9bf?f=discussion" target="_blank" rel="noopener">参考牛客</a></p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-20"><a href="#u4EE3_u7801_u5B9E_u73B0-20" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = input.length;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;length||k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1,o2)-&gt;o2-o1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:input)&#123;</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size()&gt;k)</span><br><span class="line">                maxHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:maxHeap)&#123;</span><br><span class="line">            result.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="30_u3001_u8FDE_u7EED_u5B50_u6570_u7EC4_u7684_u6700_u5927_u548C_28_u7B80_u5355_uFF0C_u52A8_u6001_u89C4_u5212_29"><a href="#30_u3001_u8FDE_u7EED_u5B50_u6570_u7EC4_u7684_u6700_u5927_u548C_28_u7B80_u5355_uFF0C_u52A8_u6001_u89C4_u5212_29" class="headerlink" title="30、连续子数组的最大和(简单，动态规划)"></a>30、连续子数组的最大和(简单，动态规划)</h2><h3 id="u9898_u76EE_u63CF_u8FF0-26"><a href="#u9898_u76EE_u63CF_u8FF0-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整型数组，数组里有正数和负数，数组中一个或者多个连续的数字组成一个子数组，求所有子数组的最大值，要求时间复杂度为O(N)</p>
<h3 id="u89E3_u9898_u601D_u8DEF-25"><a href="#u89E3_u9898_u601D_u8DEF-25" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-21"><a href="#u4EE3_u7801_u5B9E_u73B0-21" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划，主要是找到状态转移方程</span></span><br><span class="line">        <span class="comment">//设sum(j)是从array[0]到array[j]最大和</span></span><br><span class="line">        <span class="comment">//sum(j) = max(array[j], sum[j-1]+array[j])</span></span><br><span class="line">        <span class="keyword">if</span>(array.length ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result =Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            sum = Math.max(array[i],sum+array[i]);</span><br><span class="line">            result = Math.max(result,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="31_u3001_u6574_u6570_u4E2D1_u51FA_u73B0_u7684_u6B21_u6570_uFF08_u4ECE1_u5230n_u6574_u6570_u4E2D1_u51FA_u73B0_u7684_u6B21_u6570_uFF09"><a href="#31_u3001_u6574_u6570_u4E2D1_u51FA_u73B0_u7684_u6B21_u6570_uFF08_u4ECE1_u5230n_u6574_u6570_u4E2D1_u51FA_u73B0_u7684_u6B21_u6570_uFF09" class="headerlink" title="31、整数中1出现的次数（从1到n整数中1出现的次数）"></a>31、整数中1出现的次数（从1到n整数中1出现的次数）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-27"><a href="#u9898_u76EE_u63CF_u8FF0-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1到n中1出现的次数）。</p>
<blockquote>
<p>例如n=13的整数中1出现的次数，1~13中包含1的数字有1、10、11、12、13因此共出现6次</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-26"><a href="#u89E3_u9898_u601D_u8DEF-26" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>——————————–分隔符—————————————</strong></p>
<h2 id="32_u3001_u628A_u6570_u7EC4_u6392_u6210_u6700_u5C0F_u7684_u6570"><a href="#32_u3001_u628A_u6570_u7EC4_u6392_u6210_u6700_u5C0F_u7684_u6570" class="headerlink" title="32、把数组排成最小的数"></a>32、把数组排成最小的数</h2><h3 id="u9898_u76EE_u63CF_u8FF0-28"><a href="#u9898_u76EE_u63CF_u8FF0-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-27"><a href="#u89E3_u9898_u601D_u8DEF-27" class="headerlink" title="解题思路"></a>解题思路</h3><p>可以看做是排序问题，不同点在于此题是<strong>比较数字转换成字符串后相加的大小</strong>。</p>
<p>例如两个数字转换的字符串S1和S2，应该比较 <strong>S1+S2</strong> 和 <strong>S2+S1</strong> 的大小，如果 S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。</p>
<h3 id="u4EE3_u7801_u601D_u8DEF"><a href="#u4EE3_u7801_u601D_u8DEF" class="headerlink" title="代码思路"></a>代码思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        String[] nums = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i]=String.valueOf(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums,(s1,s2)-&gt;(s1+s2).compareTo(s2+s1));</span><br><span class="line">        String result =<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(String str:nums)&#123;</span><br><span class="line">            result+=str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="33_u3001_u4E11_u6570"><a href="#33_u3001_u4E11_u6570" class="headerlink" title="33、丑数"></a>33、丑数</h2><h3 id="u9898_u76EE_u63CF_u8FF0-29"><a href="#u9898_u76EE_u63CF_u8FF0-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-28"><a href="#u89E3_u9898_u601D_u8DEF-28" class="headerlink" title="解题思路"></a>解题思路</h3><p>此题需要思维灵活。由题意，只需不断从前面已知的丑数中<strong>选取合适的丑数</strong>分别乘2、3、5，选取<strong>最小</strong>的丑数加入数组即可。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-22"><a href="#u4EE3_u7801_u5B9E_u73B0-22" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">6</span>) <span class="comment">//1-6即为前6个丑数</span></span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        <span class="keyword">int</span> uglys[]=<span class="keyword">new</span> <span class="keyword">int</span>[index];<span class="comment">//存前N个丑数</span></span><br><span class="line">        uglys[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//初始化第一个值为1</span></span><br><span class="line">        <span class="keyword">int</span> i2=<span class="number">0</span>,i3=<span class="number">0</span>,i5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="comment">//找出下一个小的丑数,此步重要需理解，分别用2,3,5在丑数数组里对应的上一个丑数乘2,3,5找出最小的丑数</span></span><br><span class="line">            <span class="keyword">int</span> next2 = uglys[i2]*<span class="number">2</span>,next3=uglys[i3]*<span class="number">3</span>,next5=uglys[i5]*<span class="number">5</span>;</span><br><span class="line">            uglys[i]=Math.min(next2,Math.min(next3,next5));</span><br><span class="line">            <span class="comment">//将2,3,5对应的上一个丑数后移</span></span><br><span class="line">            <span class="keyword">if</span>(uglys[i]==next2)</span><br><span class="line">                i2++;</span><br><span class="line">            <span class="keyword">if</span>(uglys[i]==next3)</span><br><span class="line">                i3++;</span><br><span class="line">            <span class="keyword">if</span>(uglys[i]==next5)</span><br><span class="line">                i5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uglys[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="34_u3001_u7B2C_u4E00_u4E2A_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u5B57_u7B26_28_u6B67_u4E49_29"><a href="#34_u3001_u7B2C_u4E00_u4E2A_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u5B57_u7B26_28_u6B67_u4E49_29" class="headerlink" title="34、第一个只出现一次的字符(歧义)"></a>34、第一个只出现一次的字符(歧义)</h2><h3 id="u9898_u76EE_u63CF_u8FF0-30"><a href="#u9898_u76EE_u63CF_u8FF0-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符，并返回它的位置，如果没有则返回 -1（需要区分大小写）。</p>
<blockquote>
<p>Input: abacc<br>Output: b</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-29"><a href="#u89E3_u9898_u601D_u8DEF-29" class="headerlink" title="解题思路"></a>解题思路</h3><p>char类型一般为一个字节，范围在0 ~ 255。因此定义一个整形<strong>计数数组</strong>int[256]，对每个char出现次数进行计数即可。</p>
<p>计数后要按照<strong>字符串中的字符顺序</strong>查找第一个计数次数为1的字符。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-23"><a href="#u4EE3_u7801_u5B9E_u73B0-23" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            array[str.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[str.charAt(i)]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="35_u3001_u6570_u7EC4_u4E2D_u7684_u9006_u5E8F_u5BF9_uFF08_u5F52_u5E76_2C_u96BE_uFF0C_u770B_uFF09"><a href="#35_u3001_u6570_u7EC4_u4E2D_u7684_u9006_u5E8F_u5BF9_uFF08_u5F52_u5E76_2C_u96BE_uFF0C_u770B_uFF09" class="headerlink" title="35、数组中的逆序对（归并,难，看）"></a>35、数组中的逆序对（归并,难，看）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-31"><a href="#u9898_u76EE_u63CF_u8FF0-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。</p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题目保证输入的数组中没有的相同的数字</span><br><span class="line">数据范围：	</span><br><span class="line">		对于%50的数据,size&lt;=10^4</span><br><span class="line">         对于%75的数据,size&lt;=10^5	</span><br><span class="line">         对于%100的数据,size&lt;=2*10^5</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,4,5,6,7,0</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h3 id="u89E3_u9898_u601D_u8DEF-30"><a href="#u89E3_u9898_u601D_u8DEF-30" class="headerlink" title="解题思路"></a>解题思路</h3><p>分治思想，先分后治。先不断将数组一分为二，并对这分开的两部分进行相同操作；然后一边合并相邻的子数组，一边统计逆序对的数目。（实质就是归并排序的思路）</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-24"><a href="#u4EE3_u7801_u5B9E_u73B0-24" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tmp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        tmp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        mergeSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(cnt%<span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right-left&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array,left,mid);</span><br><span class="line">        mergeSort(array,mid+<span class="number">1</span>,right);</span><br><span class="line">        merge(array,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=left,j=mid+<span class="number">1</span>,k=left;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid||j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;mid)&#123;</span><br><span class="line">                tmp[k]=array[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;right)&#123;</span><br><span class="line">                tmp[k]=array[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[i]&lt;array[j])&#123;</span><br><span class="line">                tmp[k]=array[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[k]=array[j];</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">this</span>.cnt+=mid-i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(k=left;k&lt;=right;k++)&#123;</span><br><span class="line">            array[k]=tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="36_u3001_u4E24_u4E2A_u94FE_u8868_u7684_u7B2C_u4E00_u4E2A_u516C_u5171_u7ED3_u70B9"><a href="#36_u3001_u4E24_u4E2A_u94FE_u8868_u7684_u7B2C_u4E00_u4E2A_u516C_u5171_u7ED3_u70B9" class="headerlink" title="36、两个链表的第一个公共结点"></a>36、两个链表的第一个公共结点</h2><h3 id="u9898_u76EE_u63CF_u8FF0-32"><a href="#u9898_u76EE_u63CF_u8FF0-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个链表，找出它们的第一个公共结点。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-31"><a href="#u89E3_u9898_u601D_u8DEF-31" class="headerlink" title="解题思路"></a>解题思路</h3><p><img src="/2019/11/17/算法/剑指offer/剑指offer/20181212233050681.png" alt="img"></p>
<p>如图，链表1长度为 a+c，链表2长度为 b+c。声明两个指针node1和node2分别指向两个链表表头，同步向后移动。</p>
<p>node1走过 a+c 后指空，此时让它指向链表2的表头并继续向后走；同理node2走过 b+c 后指向链表1表头。</p>
<p>由于 a+c+b = b+c+a ，此时node1和node2刚好相遇，且相遇在两个链表的第一个公共结点。由此得解。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-25"><a href="#u4EE3_u7801_u5B9E_u73B0-25" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode node1 = pHead1;</span><br><span class="line">        ListNode node2 = pHead2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(node1!=node2)&#123;  <span class="comment">//终止条件：找到相同的结点</span></span><br><span class="line">            <span class="keyword">if</span>(node1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                node1 = pHead2;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                node2 =pHead1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node2=node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="37_u3001_u6570_u5B57_u5728_u6392_u5E8F_u6570_u7EC4_u4E2D_u51FA_u73B0_u7684_u6B21_u6570_28_u4E8C_u5206_29"><a href="#37_u3001_u6570_u5B57_u5728_u6392_u5E8F_u6570_u7EC4_u4E2D_u51FA_u73B0_u7684_u6B21_u6570_28_u4E8C_u5206_29" class="headerlink" title="37、数字在排序数组中出现的次数(二分)"></a>37、数字在排序数组中出现的次数(二分)</h2><h3 id="u9898_u76EE_u63CF_u8FF0-33"><a href="#u9898_u76EE_u63CF_u8FF0-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>统计一个数字在排序数组中出现的次数</p>
<blockquote>
<p>Input:<br>nums = 1, 2, 3, 3, 3, 3, 4, 6<br>K = 3</p>
<p>Output:<br>4</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-32"><a href="#u89E3_u9898_u601D_u8DEF-32" class="headerlink" title="解题思路"></a>解题思路</h3><p>二分查找，可以参考<a href="E:\Notes\算法\02-LeetCode\算法细节\二分查找细节.md" target="_blank" rel="noopener">二分查找细节</a></p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-26"><a href="#u4EE3_u7801_u5B9E_u73B0-26" class="headerlink" title="代码实现"></a>代码实现</h3><p>照着模版写就完事了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = getFirstK(array,k);</span><br><span class="line">        <span class="keyword">int</span> last = getLastK(array,k);</span><br><span class="line">        <span class="keyword">if</span>(first==-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(last ==-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> last-first+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//找最左边的</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid =left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==k)</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;k)</span><br><span class="line">                left =mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[left]==k?left:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span></span>&#123;  <span class="comment">//找最右边的</span></span><br><span class="line">        <span class="keyword">int</span> left =<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==k)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;k)</span><br><span class="line">                left=mid+<span class="number">1</span>;                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right =mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[right]==k?right:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="38_u3001_u4E8C_u53C9_u6811_u7684_u6DF1_u5EA6"><a href="#38_u3001_u4E8C_u53C9_u6811_u7684_u6DF1_u5EA6" class="headerlink" title="38、二叉树的深度"></a>38、二叉树的深度</h2><h3 id="u9898_u76EE_u63CF_u8FF0-34"><a href="#u9898_u76EE_u63CF_u8FF0-34" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 </p>
<h3 id="u89E3_u9898_u601D_u8DEF-33"><a href="#u89E3_u9898_u601D_u8DEF-33" class="headerlink" title="解题思路"></a>解题思路</h3><p> 分别对左右子树递归计算深度，取深度更大的一个。 </p>
<p><img src="/2019/11/17/算法/剑指offer/剑指offer/124213_1560686577137_ba355101-4a93-4c71-94fb-1da83639727b.jpg" alt="img"></p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-27"><a href="#u4EE3_u7801_u5B9E_u73B0-27" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> root==<span class="keyword">null</span>?<span class="number">0</span>:<span class="number">1</span>+Math.max(TreeDepth(root.left),TreeDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="39_u3001_u5E73_u8861_u4E8C_u53C9_u6811"><a href="#39_u3001_u5E73_u8861_u4E8C_u53C9_u6811" class="headerlink" title="39、平衡二叉树"></a>39、平衡二叉树</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树</p>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>平衡二叉树的平衡因子的绝对值&lt;= 1. </p>
<p><img src="/2019/11/17/算法/剑指offer/剑指offer/124213_1560686577152_af1d1166-63af-47b6-9aa3-2bf2bd37bd03.jpg" alt="img"></p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val =<span class="number">0</span></span><br><span class="line">    TreeNode left ==<span class="keyword">null</span>;</span><br><span class="line">    TreeNode right ==<span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val =val;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//abs：绝对值</span></span><br><span class="line">        <span class="keyword">boolean</span> condition = Math.abs(treePath(root.left)-treePath(root.right)) &lt;=<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">return</span> condition &amp;&amp; IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treePath</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="keyword">null</span>?<span class="number">0</span>:<span class="number">1</span>+Math.max(treePath(root.left),treePath(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="40_u3001_u6570_u7EC4_u4E2D_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u6570_u5B57"><a href="#40_u3001_u6570_u7EC4_u4E2D_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u6570_u5B57" class="headerlink" title="40、数组中只出现一次的数字"></a>40、数组中只出现一次的数字</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-1"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-1" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>一个整形数组里除了两个数字之外，其他的数字都出现了两次。请写出程序找出这两个只出现一次的数字</p>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-1"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-1" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p><strong>重点</strong>：注意题意，两个数只出现<strong>一次</strong>，其他数都出现<strong>偶数次</strong>。</p>
<p>方法一：<strong>HashSet</strong>。不包含则加入，包含则移除。最终出现偶数次的数一定都会被移除，仅留只出现了一次的数。</p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-1"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><p>法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set =<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(num))&#123;</span><br><span class="line">                set.remove(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;Integer&gt; it = set.iterator();</span><br><span class="line">        num1[<span class="number">0</span>] = it.next();</span><br><span class="line">        num2[<span class="number">0</span>] = it.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="41_u3001_u548C_u4E3AS_u7684_u4E24_u4E2A_u6570_u5B57"><a href="#41_u3001_u548C_u4E3AS_u7684_u4E24_u4E2A_u6570_u5B57" class="headerlink" title="41、和为S的两个数字"></a>41、和为S的两个数字</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-2"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-2" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
</blockquote>
<blockquote>
<p>输出描述：输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序  </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-2"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-2" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>夹逼思想，使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<p>如果两个指针指向元素的和 sum == target，那么得到要求的结果；<br>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；<br>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-2"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-2" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = array[i]+array[j];</span><br><span class="line">            <span class="keyword">if</span>(cur == sum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(array[i],array[j]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur&lt;sum)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="42_u3001_u548C_u4E3AS_u7684_u8FDE_u7EED_u6B63_u6570_u5E8F_u5217_uFF08_u770B_uFF0C_u96BE_uFF09"><a href="#42_u3001_u548C_u4E3AS_u7684_u8FDE_u7EED_u6B63_u6570_u5E8F_u5217_uFF08_u770B_uFF0C_u96BE_uFF09" class="headerlink" title="42、和为S的连续正数序列（看，难）"></a>42、和为S的连续正数序列（看，难）</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-3"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-3" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>输出所有和为 S 的连续正数序列。 </p>
<p>例如和为 100 的连续序列有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; [9, 10, 11, 12, 13, 14, 15, 16]</span><br><span class="line">&gt; [18, 19, 20, 21, 22]。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-3"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-3" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p> 夹逼思想，定义正数序列的左边界small和右边界big，求small到big的和。和比所求小则big后移，比所求大则small后移。 </p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-3"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-3" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=<span class="number">1</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> small =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> big=<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(small&lt;(sum+<span class="number">1</span>)/<span class="number">2</span>)&#123; <span class="comment">//要求最少两个数，所以small最大为（sum+1)/2</span></span><br><span class="line">            <span class="keyword">int</span> curSum = <span class="number">0</span>;<span class="comment">//求small到big的和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=small;i&lt;=big;i++)&#123;</span><br><span class="line">                curSum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//夹逼思想，小则big后移，大则small后移</span></span><br><span class="line">            <span class="keyword">if</span>(curSum&lt;sum)&#123;</span><br><span class="line">                big++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum&gt;sum)&#123;</span><br><span class="line">                small++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//相等，即为所求</span></span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=small;i&lt;=big;i++)&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">                small++;  <span class="comment">//往下继续找满足和为sum的答案</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="43_u3001_u5DE6_u65CB_u8F6C_u5B57_u7B26_u4E32"><a href="#43_u3001_u5DE6_u65CB_u8F6C_u5B57_u7B26_u4E32" class="headerlink" title="43、左旋转字符串"></a>43、左旋转字符串</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-4"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-4" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-4"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-4" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p> 先将整个字符串翻转，然后将每个单词翻转。 </p>
<p>分三步走。（交换步骤顺序也可）</p>
<p>step1：先将左边3个字符串进行翻转：[abc]XYZdef –&gt; [cba]XYZdef</p>
<p>step2：再将右边剩余字符串进行翻转：cba[XYZdef] –&gt; cba[fedZYX]</p>
<p>step3：最后将整个字符串进行翻转： cbafedZYX –&gt; XYZdefabc</p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-4"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-4" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] chars =str.toCharArray();</span><br><span class="line">        <span class="comment">//step1:先将左边3个字符串进行翻转：[abc]XYZdef --&gt; [cba]XYZdef</span></span><br><span class="line">        reverse(chars,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//step2:再将右边剩余字符串进行翻转：cba[XYZdef] --&gt; cba[fedZYX]</span></span><br><span class="line">        reverse(chars,n,chars.length-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//step3:最后将整个字符串进行翻转：cbafedZYX --&gt; XYZdefabc</span></span><br><span class="line">        reverse(chars,<span class="number">0</span>,chars.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[start];</span><br><span class="line">            chars[start] = chars[end];</span><br><span class="line">            chars[end]=temp;</span><br><span class="line">            </span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="44_u3001_u7FFB_u8F6C_u5355_u8BCD_u987A_u5E8F_u5217"><a href="#44_u3001_u7FFB_u8F6C_u5355_u8BCD_u987A_u5E8F_u5217" class="headerlink" title="44、翻转单词顺序列"></a>44、翻转单词顺序列</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-5"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-5" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;I am a student.&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;student. a am I&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-5"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-5" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>与上一题类似， 先翻转每个单词的顺序，再翻转整个句子的顺序。 </p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-5"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-5" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> length =chars.length;</span><br><span class="line">        <span class="keyword">int</span> startIndex=<span class="number">0</span>;<span class="comment">//单词开始标记</span></span><br><span class="line">        <span class="keyword">int</span> endIndex=<span class="number">0</span>;<span class="comment">//单词结束标记</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//（注意）与上一题不同：翻转每个单词的字母顺序</span></span><br><span class="line">        <span class="keyword">while</span>(endIndex &lt;= length)&#123;</span><br><span class="line">            <span class="comment">//遇到空格或到句末，翻转单词</span></span><br><span class="line">            <span class="keyword">if</span>(endIndex == length||chars[endIndex]==<span class="string">' '</span>)&#123;</span><br><span class="line">                reversed(chars,startIndex,endIndex-<span class="number">1</span>);</span><br><span class="line">                startIndex = endIndex+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            endIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        reversed(chars,<span class="number">0</span>,length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reversed</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[start];</span><br><span class="line">            chars[start] = chars[end];</span><br><span class="line">            chars[end]= temp;</span><br><span class="line">            </span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="45_u3001_u6251_u514B_u724C_u987A_u5B50"><a href="#45_u3001_u6251_u514B_u724C_u987A_u5B50" class="headerlink" title="45、扑克牌顺子"></a>45、扑克牌顺子</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-6"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-6" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张_)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-6"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-6" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p> 先对数组排序，计算大小王（癞子）数量。然后计算剩下的数两两的差值减1即为需要用癞子替代的张数。题那么长都是废话，别想太多正常找就行。 </p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-6"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-6" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span>||numbers.length&lt;<span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="keyword">int</span> sum0=<span class="number">0</span>;<span class="comment">//大小王数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                sum0++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =sum0;i&lt;numbers.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//有相等的牌不可能成为顺子</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i+<span class="number">1</span>]==numbers[i]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//两个数之间差了几张牌</span></span><br><span class="line">            <span class="keyword">int</span> interval= numbers[i+<span class="number">1</span>]-numbers[i]-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//相差太大，大小王不够</span></span><br><span class="line">            <span class="keyword">if</span>(interval&gt;sum0) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            sum0-=interval;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="46_u3001_u5B69_u5B50_u4EEC_u7684_u6E38_u620F_uFF08_u5706_u5708_u4E2D_u6700_u540E_u5269_u4E0B_u7684_u6570_uFF09"><a href="#46_u3001_u5B69_u5B50_u4EEC_u7684_u6E38_u620F_uFF08_u5706_u5708_u4E2D_u6700_u540E_u5269_u4E0B_u7684_u6570_uFF09" class="headerlink" title="46、孩子们的游戏（圆圈中最后剩下的数）"></a>46、孩子们的游戏（圆圈中最后剩下的数）</h3><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-7"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-7" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>如果没有小朋友，请返回-1</p>
</blockquote>
<p>简化版本：</p>
<blockquote>
<p>一个环，每次删除第m个数字，求最后一个数字，如0，1，2，3，4这5个数字，从0开始每次删除第3个数字，则依次删除2，0，4，1，最后一个数字是3 </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-7"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-7" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>法一： 约瑟夫经典解法，O(N)，空间复杂度O(1) </p>
<p><strong>约瑟夫环</strong>，公式：</p>
<blockquote>
<p>n = 1： f(n, m) = 0<br>n &gt; 1： f(n, m) = [f(n - 1, m) + m] % n </p>
</blockquote>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-7"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-7" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><p>法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            f=(f+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="46_u3001_u6C421+2+3+_u2026+n"><a href="#46_u3001_u6C421+2+3+_u2026+n" class="headerlink" title="46、求1+2+3+…+n"></a>46、求1+2+3+…+n</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-8"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-8" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p> 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-8"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-8" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p> 递归相加。此题关键在于如何跳出递归，基本方向是采用逻辑与或的方式来计算，与的时候通过n&gt;0来短路，这样在n=0的时候不需要计算递归的值，或的时候通过n==0来短路，在n=0的时候可以短路逻辑或运算。 </p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-8"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-8" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = n;</span><br><span class="line">    <span class="comment">//boolean b = (n &gt; 0) &amp;&amp; (sum += Sum_Solution(n - 1)) &gt; 0;</span></span><br><span class="line">    <span class="keyword">boolean</span> b = (n == <span class="number">0</span>) || (sum += Sum_Solution(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="47_u3001_u4E0D_u7528_u52A0_u51CF_u4E58_u9664_u505A_u52A0_u6CD5"><a href="#47_u3001_u4E0D_u7528_u52A0_u51CF_u4E58_u9664_u505A_u52A0_u6CD5" class="headerlink" title="47、不用加减乘除做加法"></a>47、不用加减乘除做加法</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-9"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-9" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p> 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 </p>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-9"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-9" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p> 位运算。a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。 </p>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215?answerType=1&amp;f=discussion来源：牛客网" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215?answerType=1&amp;f=discussion来源：牛客网</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先看十进制是如何做的： 5+7=12，三步走</span><br><span class="line">第一步：相加各位的值，不算进位，得到2。</span><br><span class="line">第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</span><br><span class="line">第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</span><br><span class="line"></span><br><span class="line">同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，</span><br><span class="line">得到010，二进制每位相加就相当于各位做异或操作，101^111。</span><br><span class="line">第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</span><br><span class="line">第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。</span><br><span class="line">继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果</span><br></pre></td></tr></table></figure>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-9"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-9" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = num1 ^ num2;</span><br><span class="line">            num2 = (num1 &amp; num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1 =tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="48_u3001_u628A_u5B57_u7B26_u4E32_u8F6C_u6362_u6210_u6574_u6570_28_u51FA_u9519_29"><a href="#48_u3001_u628A_u5B57_u7B26_u4E32_u8F6C_u6362_u6210_u6574_u6570_28_u51FA_u9519_29" class="headerlink" title="48、把字符串转换成整数(出错)"></a>48、把字符串转换成整数(出错)</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-10"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-10" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p> 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 </p>
</blockquote>
<blockquote>
<p>输入描述:<br>输入一个字符串，包括数字字母符号，可以为空<br>输出描述:<br>如果是合法的数值表达则返回该数字，否则返回0 </p>
</blockquote>
<p>示例</p>
<blockquote>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; +2147483647</span><br><span class="line">&gt;     1a33</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 2147483647</span><br><span class="line">&gt;     0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-10"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-10" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>正常转换即可</p>
<p> 此题主要是注意细节：<br>1、功能测试：输入有+-号情况，区分正负数和0<br>2、特殊输入：空字符串情况，输入非数字字符串情况，如a12<br>3、边界值：最大正整数和最小负整数溢出情况 </p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-10"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-10" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span> isNegative = chars[<span class="number">0</span>] ==<span class="string">'-'</span>;<span class="comment">//判断是否有负号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;(chars[i]==<span class="string">'+'</span>||chars[i]==<span class="string">'-'</span>)) <span class="keyword">continue</span>;<span class="comment">//跳过正负号</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(chars[i]&lt;<span class="string">'0'</span>||chars[i]&gt;<span class="string">'9'</span>) <span class="comment">//非法输入</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            result = result*<span class="number">10</span>+(chars[i]-<span class="string">'0'</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative?-result:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="49_u3001_u6570_u7EC4_u4E2D_u91CD_u590D_u7684_u6570_u5B57"><a href="#49_u3001_u6570_u7EC4_u4E2D_u91CD_u590D_u7684_u6570_u5B57" class="headerlink" title="49、数组中重复的数字"></a>49、数组中重复的数字</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-11"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-11" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-11"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-11" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p><img src="/2019/11/17/算法/剑指offer/剑指offer/20160525171645123" alt="这里写图片描述"></p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-11"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-11" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers ==<span class="keyword">null</span>||length&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(numbers[i]!=i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[i]==numbers[numbers[i]])&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>]=numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    swap(numbers,i,numbers[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="50_u3001_u6784_u5EFA_u4E58_u79EF_u6570_u7EC4"><a href="#50_u3001_u6784_u5EFA_u4E58_u79EF_u6570_u7EC4" class="headerlink" title="50、构建乘积数组"></a>50、构建乘积数组</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-12"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-12" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0] <em> A[1] </em> … <em> A[i-1] </em> A[i+1] <em> … </em> A[n-1]。不能使用除法。 </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-12"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-12" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p><img src="/2019/11/17/算法/剑指offer/剑指offer/20181215213441301.png" alt="img"></p>
<p>分三步走。如图，构建左下部分的前向乘积数组和右上部分的后向乘积数组。</p>
<p>step1：构建前向乘积数组C[i] = A[0] <em> A[1] </em> … <em> A[i-1]，即C[i] = C[i-1] </em> A[i-1]</p>
<p>step2：构建后向乘积数组D[i] = A[n-1] <em> A[n-2] </em> …A[n-i+1]，即D[i] = D[i+1] * A[i+1]</p>
<p>step3：B[i] = C[i] * D[i]</p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-12"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-12" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> len=A.length;</span><br><span class="line">        <span class="keyword">int</span>[] B=<span class="keyword">new</span> <span class="keyword">int</span>[len];<span class="comment">//乘积数组</span></span><br><span class="line">        <span class="keyword">int</span>[] C=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] D=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构建前向乘积数组C[i]=A[0]*A[1]*...*A[i-1],即C[i]=C[i-1]*A[i-1];</span></span><br><span class="line">        C[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            C[i]=C[i-<span class="number">1</span>]*A[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构建后向乘积数组D[i]=A[n-1]*A[n-2]*...*A[n-i+1],即D[i]=D[i+1]*A[i+1]</span></span><br><span class="line">        D[len-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            D[i]=D[i+<span class="number">1</span>]*A[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//B[i]=C[i]*D[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            B[i]=C[i]*D[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="51_u3001_u6B63_u5219_u8868_u8FBE_u5F0F_u5339_u914D_uFF08_u6CA1_u505A_uFF09"><a href="#51_u3001_u6B63_u5219_u8868_u8FBE_u5F0F_u5339_u914D_uFF08_u6CA1_u505A_uFF09" class="headerlink" title="51、正则表达式匹配（没做）"></a>51、正则表达式匹配（没做）</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-13"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-13" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配 </p>
</blockquote>
<h2 id="52_u3001_u8868_u793A_u6570_u503C_u7684_u5B57_u7B26_u4E32_uFF08_u6CA1_u505A_uFF09"><a href="#52_u3001_u8868_u793A_u6570_u503C_u7684_u5B57_u7B26_u4E32_uFF08_u6CA1_u505A_uFF09" class="headerlink" title="52、表示数值的字符串（没做）"></a>52、表示数值的字符串（没做）</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-14"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-14" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><h2 id="53_u3001_u5B57_u7B26_u6D41_u4E2D_u7B2C_u4E00_u4E2A_u4E0D_u91CD_u590D_u7684_u5B57_u7B26"><a href="#53_u3001_u5B57_u7B26_u6D41_u4E2D_u7B2C_u4E00_u4E2A_u4E0D_u91CD_u590D_u7684_u5B57_u7B26" class="headerlink" title="53、字符流中第一个不重复的字符"></a>53、字符流中第一个不重复的字符</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-15"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-15" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p> 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br>（如果当前字符流没有存在出现一次的字符，返回#字符。） </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-13"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-13" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p> 原理同T34，定义下标计数数组，插入字符时计数，同时记录字符串。输出时按照字符串中<strong>字符顺序</strong>找到第一个计数为1的即可。 </p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-13"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-13" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        str+=ch;</span><br><span class="line">        count[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(count[str.charAt(i)]==<span class="number">1</span>) </span><br><span class="line">               <span class="keyword">return</span> str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="54_u3001_u94FE_u8868_u4E2D_u73AF_u7684_u5165_u53E3_u7ED3_u70B9"><a href="#54_u3001_u94FE_u8868_u4E2D_u73AF_u7684_u5165_u53E3_u7ED3_u70B9" class="headerlink" title="54、链表中环的入口结点"></a>54、链表中环的入口结点</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-16"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-16" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p> 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 </p>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-14"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-14" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>定义快慢两个指针，相遇后（环中相汇点）将快指针指向pHead 然后一起走，每次往后挪一位，相遇的节点即为所求。</p>
<p>详细分析：相遇即p1\==p2时，p2所经过节点数为2x,p1所经过节点数为x,设环中有n个节点,p2比p1多走一圈有2x=n+x; n=x;可以看出p1实际走了一个环的步数，再让p2指向链表头部，p1位置不变，p1,p2每次走一步直到p1==p2; 此时p1指向环的入口。</p>
<h3 id="3_u3001_u89E3_u9898_u601D_u8DEF"><a href="#3_u3001_u89E3_u9898_u601D_u8DEF" class="headerlink" title="3、解题思路"></a>3、解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>||pHead.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="keyword">null</span>&amp;&amp;fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(slow!=<span class="keyword">null</span>&amp;&amp;fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=pHead;</span><br><span class="line">            <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">                slow=slow.next;</span><br><span class="line">                fast=fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="55_u3001_u5220_u9664_u94FE_u8868_u4E2D_u91CD_u590D_u7684_u7ED3_u70B9"><a href="#55_u3001_u5220_u9664_u94FE_u8868_u4E2D_u91CD_u590D_u7684_u7ED3_u70B9" class="headerlink" title="55、删除链表中重复的结点"></a>55、删除链表中重复的结点</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-17"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-17" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-15"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-15" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>需要定义一个指针preNode记录前一个不重复结点，然后向后查找值相同的结点，重复查找后删除，之后改指针即可。</p>
<p>需要注意头结点是否重复</p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-14"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-14" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode preNode = <span class="keyword">null</span>;</span><br><span class="line">        ListNode node =pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next!=<span class="keyword">null</span>&amp;&amp;node.val==node.next.val)&#123;</span><br><span class="line">                <span class="keyword">int</span> val =node.val;</span><br><span class="line">                <span class="comment">//查找重复</span></span><br><span class="line">                <span class="keyword">while</span>(node.next!=<span class="keyword">null</span>&amp;&amp;node.next.val==val)&#123;</span><br><span class="line">                    node=node.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(preNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//能执行到此步说明头结点重复了</span></span><br><span class="line">                    <span class="comment">//改变pHead使其指向第一个不重复的结点</span></span><br><span class="line">                    pHead=node.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//改指针，去掉中间重复的链</span></span><br><span class="line">                    preNode.next=node.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preNode=node;<span class="comment">//头结点不重复</span></span><br><span class="line">            &#125;</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="55_u3001_u4E8C_u53C9_u6811_u7684_u4E0B_u4E00_u4E2A_u7ED3_u70B9"><a href="#55_u3001_u4E8C_u53C9_u6811_u7684_u4E0B_u4E00_u4E2A_u7ED3_u70B9" class="headerlink" title="55、二叉树的下一个结点"></a>55、二叉树的下一个结点</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-18"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-18" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-16"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-16" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>分情况讨论。中序遍历：左 -&gt; 根 -&gt; 右</p>
<p>情况一：该结点有右子树，直接进行中序遍历即可。</p>
<p>情况二：该结点无右子树，则需要访问其父节点。此时又分两种情况：</p>
<ol>
<li>若该结点是父结点的左子结点，继续访问父结点即可 </li>
<li>若是右子结点，则指针向上移动到其父结点，继续判断。 </li>
</ol>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-15"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-15" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right!=<span class="keyword">null</span>)&#123;<span class="comment">//该结点有右子树，进行中序遍历即可</span></span><br><span class="line">            pNode =pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                pNode=pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//若该结点无右子树，则需返回</span></span><br><span class="line">            <span class="keyword">while</span>(pNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pNode.next.left==pNode)&#123;<span class="comment">//若该节点是父节点的左孩子</span></span><br><span class="line">                    <span class="keyword">return</span> pNode.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//若是又孩子，则向上移动</span></span><br><span class="line">                    pNode = pNode.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
            <a href="/tags/剑指offer/" rel="tag"># 剑指offer</a>
          
        </div>
      

      
      
      

      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="HyCoder">
            
              <p class="site-author-name" itemprop="name">HyCoder</p>
              <p class="site-description motion-element" itemprop="description">学习，记录，总结</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#01_u3001_u4E8C_u7EF4_u6570_u7EC4_u4E2D_u7684_u67E5_u627E_uFF08_u4E00_u822C_uFF09"><span class="nav-text">01、二维数组中的查找（一般）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02_u3001_u66FF_u6362_u7A7A_u683C_uFF08_u770B_u4E00_u4E0B_u5C31_u4F1A_uFF09"><span class="nav-text">02、替换空格（看一下就会）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-1"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-1"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-1"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03_u3001_u4ECE_u5C3E_u5230_u5934_u6253_u5370_u94FE_u8868_uFF08_u4E00_u822C_uFF09"><span class="nav-text">03、从尾到头打印链表（一般）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-2"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-2"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-2"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04_u3001_u91CD_u5EFA_u4E8C_u53C9_u6811_uFF08_u4E00_u822C_uFF09"><span class="nav-text">04、重建二叉树（一般）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-3"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-3"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-3"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05_u3001_u7528_u4E24_u4E2A_u6808_u5B9E_u73B0_u961F_u5217_28_u7B80_u5355_29"><span class="nav-text">05、用两个栈实现队列(简单)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-4"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-4"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u5B9E_u73B0_u4EE3_u7801"><span class="nav-text">实现代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#06_u3001_u65CB_u8F6C_u6570_u7EC4_u7684_u6700_u5C0F_u6570_u5B57_uFF08_u540CLeetCode153_uFF0C154_uFF0C_u4E00_u822C_uFF09"><span class="nav-text">06、旋转数组的最小数字（同LeetCode153，154，一般）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-5"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-5"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-4"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#07_u3001_u6590_u6CE2_u90A3_u5951_u6570_u5217_uFF08_u7B80_u5355_uFF09"><span class="nav-text">07、斐波那契数列（简单）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-6"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-6"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-5"><span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u884D_u751F_u9898"><span class="nav-text">衍生题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11_u3001_u4E8C_u8FDB_u5236_u4E2D1_u7684_u4E2A_u6570_uFF08_u4E00_u822C_uFF09"><span class="nav-text">11、二进制中1的个数（一般）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-7"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-7"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-6"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12_u3001_u6570_u503C_u7684_u6574_u6570_u6B21_u65B9_uFF08_u6CA1_u505A_uFF09"><span class="nav-text">12、数值的整数次方（没做）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-8"><span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13_u3001_u8C03_u6574_u6570_u7EC4_u987A_u5E8F_u4F7F_u5947_u6570_u4F4D_u4E8E_u5076_u6570_u524D_u9762_uFF08_u5F85_u5B8C_u5584_uFF09"><span class="nav-text">13、调整数组顺序使奇数位于偶数前面（待完善）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-9"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-8"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-7"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14_u3001_u94FE_u8868_u4E2D_u5012_u6570_u7B2Ck_u4E2A_u8282_u70B9_28_u4E00_u822C_29"><span class="nav-text">14、链表中倒数第k个节点(一般)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-10"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-9"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-8"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15_u3001_u53CD_u8F6C_u94FE_u8868_uFF08_u4E00_u822C_uFF09"><span class="nav-text">15、反转链表（一般）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-11"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-10"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-9"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16_u3001_u5408_u5E76_u4E24_u4E2A_u6392_u5E8F_u7684_u94FE_u8868_uFF08_u9012_u5F52_uFF0C_u7B80_u5355_uFF09"><span class="nav-text">16、合并两个排序的链表（递归，简单）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-12"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-11"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-10"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17_u3001_u6811_u7684_u5B50_u7ED3_u6784_uFF08_u4E00_u822C_uFF09"><span class="nav-text">17、树的子结构（一般）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-13"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-12"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u5B9E_u73B0_u4EE3_u7801-1"><span class="nav-text">实现代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18_u3001_u4E8C_u53C9_u6811_u7684_u955C_u50CF_uFF08_u7B80_u5355_uFF09"><span class="nav-text">18、二叉树的镜像（简单）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-14"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-13"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-11"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19_u3001_u987A_u65F6_u9488_u6253_u5370_u77E9_u9635_uFF08_u7B80_u5355_uFF09"><span class="nav-text">19、顺时针打印矩阵（简单）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-15"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-14"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-12"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20_u3001_u5305_u542Bmin_u51FD_u6570_u7684_u6808_uFF08_u4E00_u822C_uFF09"><span class="nav-text">20、包含min函数的栈（一般）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-16"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-15"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u5B9E_u73B0_u4EE3_u7801-2"><span class="nav-text">实现代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21_u3001_u6808_u7684_u538B_u5165_u3001_u5F39_u51FA_u5E8F_u5217_uFF08_u4E00_u822C_uFF09"><span class="nav-text">21、栈的压入、弹出序列（一般）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-17"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-16"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-13"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22_u3001_u4ECE_u4E0A_u5F80_u4E0B_u6253_u5370_u4E8C_u53C9_u6811_uFF08_u4E00_u822C_uFF0CBFS_uFF09"><span class="nav-text">22、从上往下打印二叉树（一般，BFS）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-18"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-17"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-14"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23_u3001_u4E8C_u53C9_u641C_u7D22_u6811_u7684_u540E_u5E8F_u904D_u5386_u5E8F_u5217_uFF08_u4E00_u822C_uFF09"><span class="nav-text">23、二叉搜索树的后序遍历序列（一般）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-19"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-18"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-15"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24_u3001_u4E8C_u53C9_u6811_u4E2D_u548C_u4E3A_u67D0_u4E00_u503C_u7684_u8DEF_u5F84_28_u96BE_29"><span class="nav-text">24、二叉树中和为某一值的路径(难)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-20"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-19"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-16"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25_u3001_u590D_u6742_u94FE_u8868_u7684_u590D_u5236_uFF08_u96BE_uFF09"><span class="nav-text">25、复杂链表的复制（难）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-21"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-20"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-17"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26_u3001_u4E8C_u53C9_u641C_u7D22_u6811_u548C_u53CC_u5411_u94FE_u8868_uFF08_u96BE_uFF09"><span class="nav-text">26、二叉搜索树和双向链表（难）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-22"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-21"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-18"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27_u3001_u5B57_u7B26_u4E32_u7684_u6392_u5217_uFF08_u96BE_uFF0C_u770B_uFF09"><span class="nav-text">27、字符串的排列（难，看）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-23"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-22"><span class="nav-text">解题思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28_u3001_u6570_u7EC4_u4E2D_u51FA_u73B0_u6B21_u6570_u8D85_u8FC7_u4E00_u534A_u7684_u6570_u5B57"><span class="nav-text">28、数组中出现次数超过一半的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-24"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-23"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-19"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29_u3001_u6700_u5C0F_u7684k_u4E2A_u6570_uFF08_u4E00_u822C_uFF0C_u5806_uFF09"><span class="nav-text">29、最小的k个数（一般，堆）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-25"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-24"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-20"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30_u3001_u8FDE_u7EED_u5B50_u6570_u7EC4_u7684_u6700_u5927_u548C_28_u7B80_u5355_uFF0C_u52A8_u6001_u89C4_u5212_29"><span class="nav-text">30、连续子数组的最大和(简单，动态规划)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-26"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-25"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-21"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31_u3001_u6574_u6570_u4E2D1_u51FA_u73B0_u7684_u6B21_u6570_uFF08_u4ECE1_u5230n_u6574_u6570_u4E2D1_u51FA_u73B0_u7684_u6B21_u6570_uFF09"><span class="nav-text">31、整数中1出现的次数（从1到n整数中1出现的次数）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-27"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-26"><span class="nav-text">解题思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32_u3001_u628A_u6570_u7EC4_u6392_u6210_u6700_u5C0F_u7684_u6570"><span class="nav-text">32、把数组排成最小的数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-28"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-27"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u601D_u8DEF"><span class="nav-text">代码思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33_u3001_u4E11_u6570"><span class="nav-text">33、丑数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-29"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-28"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-22"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34_u3001_u7B2C_u4E00_u4E2A_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u5B57_u7B26_28_u6B67_u4E49_29"><span class="nav-text">34、第一个只出现一次的字符(歧义)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-30"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-29"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-23"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35_u3001_u6570_u7EC4_u4E2D_u7684_u9006_u5E8F_u5BF9_uFF08_u5F52_u5E76_2C_u96BE_uFF0C_u770B_uFF09"><span class="nav-text">35、数组中的逆序对（归并,难，看）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-31"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-30"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-24"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36_u3001_u4E24_u4E2A_u94FE_u8868_u7684_u7B2C_u4E00_u4E2A_u516C_u5171_u7ED3_u70B9"><span class="nav-text">36、两个链表的第一个公共结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-32"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-31"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-25"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37_u3001_u6570_u5B57_u5728_u6392_u5E8F_u6570_u7EC4_u4E2D_u51FA_u73B0_u7684_u6B21_u6570_28_u4E8C_u5206_29"><span class="nav-text">37、数字在排序数组中出现的次数(二分)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-33"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-32"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-26"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38_u3001_u4E8C_u53C9_u6811_u7684_u6DF1_u5EA6"><span class="nav-text">38、二叉树的深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u9898_u76EE_u63CF_u8FF0-34"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u89E3_u9898_u601D_u8DEF-33"><span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4EE3_u7801_u5B9E_u73B0-27"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39_u3001_u5E73_u8861_u4E8C_u53C9_u6811"><span class="nav-text">39、平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40_u3001_u6570_u7EC4_u4E2D_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u6570_u5B57"><span class="nav-text">40、数组中只出现一次的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-1"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-1"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-1"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41_u3001_u548C_u4E3AS_u7684_u4E24_u4E2A_u6570_u5B57"><span class="nav-text">41、和为S的两个数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-2"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-2"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-2"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42_u3001_u548C_u4E3AS_u7684_u8FDE_u7EED_u6B63_u6570_u5E8F_u5217_uFF08_u770B_uFF0C_u96BE_uFF09"><span class="nav-text">42、和为S的连续正数序列（看，难）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-3"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-3"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-3"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43_u3001_u5DE6_u65CB_u8F6C_u5B57_u7B26_u4E32"><span class="nav-text">43、左旋转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-4"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-4"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-4"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44_u3001_u7FFB_u8F6C_u5355_u8BCD_u987A_u5E8F_u5217"><span class="nav-text">44、翻转单词顺序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-5"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-5"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-5"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45_u3001_u6251_u514B_u724C_u987A_u5B50"><span class="nav-text">45、扑克牌顺子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-6"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-6"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-6"><span class="nav-text">3、代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46_u3001_u5B69_u5B50_u4EEC_u7684_u6E38_u620F_uFF08_u5706_u5708_u4E2D_u6700_u540E_u5269_u4E0B_u7684_u6570_uFF09"><span class="nav-text">46、孩子们的游戏（圆圈中最后剩下的数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-7"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-7"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-7"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46_u3001_u6C421+2+3+_u2026+n"><span class="nav-text">46、求1+2+3+…+n</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-8"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-8"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-8"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47_u3001_u4E0D_u7528_u52A0_u51CF_u4E58_u9664_u505A_u52A0_u6CD5"><span class="nav-text">47、不用加减乘除做加法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-9"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-9"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-9"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48_u3001_u628A_u5B57_u7B26_u4E32_u8F6C_u6362_u6210_u6574_u6570_28_u51FA_u9519_29"><span class="nav-text">48、把字符串转换成整数(出错)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-10"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-10"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-10"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49_u3001_u6570_u7EC4_u4E2D_u91CD_u590D_u7684_u6570_u5B57"><span class="nav-text">49、数组中重复的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-11"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-11"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-11"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50_u3001_u6784_u5EFA_u4E58_u79EF_u6570_u7EC4"><span class="nav-text">50、构建乘积数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-12"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-12"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-12"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51_u3001_u6B63_u5219_u8868_u8FBE_u5F0F_u5339_u914D_uFF08_u6CA1_u505A_uFF09"><span class="nav-text">51、正则表达式匹配（没做）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-13"><span class="nav-text">1、题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52_u3001_u8868_u793A_u6570_u503C_u7684_u5B57_u7B26_u4E32_uFF08_u6CA1_u505A_uFF09"><span class="nav-text">52、表示数值的字符串（没做）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-14"><span class="nav-text">1、题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53_u3001_u5B57_u7B26_u6D41_u4E2D_u7B2C_u4E00_u4E2A_u4E0D_u91CD_u590D_u7684_u5B57_u7B26"><span class="nav-text">53、字符流中第一个不重复的字符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-15"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-13"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-13"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54_u3001_u94FE_u8868_u4E2D_u73AF_u7684_u5165_u53E3_u7ED3_u70B9"><span class="nav-text">54、链表中环的入口结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-16"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-14"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u89E3_u9898_u601D_u8DEF"><span class="nav-text">3、解题思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55_u3001_u5220_u9664_u94FE_u8868_u4E2D_u91CD_u590D_u7684_u7ED3_u70B9"><span class="nav-text">55、删除链表中重复的结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-17"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-15"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-14"><span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55_u3001_u4E8C_u53C9_u6811_u7684_u4E0B_u4E00_u4E2A_u7ED3_u70B9"><span class="nav-text">55、二叉树的下一个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1_u3001_u9898_u76EE_u63CF_u8FF0-18"><span class="nav-text">1、题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2_u3001_u89E3_u9898_u601D_u8DEF-16"><span class="nav-text">2、解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-15"><span class="nav-text">3、代码实现</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HyCoder</span>

  
  
</div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>










        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'cn10j7NOISCtjqnQDh9lpxJt-gzGzoHsz',
        appKey: 'EAiimqx61ssfShQ7DYMUekYR',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("cn10j7NOISCtjqnQDh9lpxJt-gzGzoHsz", "EAiimqx61ssfShQ7DYMUekYR");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
