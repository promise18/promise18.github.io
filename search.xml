<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>行为型模式之观察者模式</title>
    <url>/2019/11/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。例如，某种商品的物价上涨时会导致部分商家高兴，而消费者伤心；还有，当我们开车到交叉路口时，遇到红灯会停，遇到绿灯会行。这样的例子还有很多，例如，股票价格与股民、微信公众号与微信用户、气象局的天气预报与听众、小偷与警察等。</p>
<p>在软件世界也是这样，例如，Excel 中的数据与折线图、饼状图、柱状图之间的关系；MVC 模式中的模型与视图的关系；事件模型中的事件源与事件处理者。所有这些，如果用观察者模式来实现就非常方便。</p>
<h2 id="u6A21_u5F0F_u7684_u5B9A_u4E49_u4E0E_u7279_u70B9"><a href="#u6A21_u5F0F_u7684_u5B9A_u4E49_u4E0E_u7279_u70B9" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h2><p>观察者（Observer）模式的定义：==指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。==这种模式有时又称作发布-订阅模式、模型-视图模式，<strong>它是对象行为型模式。</strong></p>
<p>观察者模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>目标与观察者之间建立了一套触发机制。</li>
</ol>
<p>它的主要缺点如下。</p>
<ol>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li>
<li><strong>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</strong></li>
</ol>
<h2 id="u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0"><a href="#u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。</p>
<h3 id="u6A21_u5F0F_u7684_u7ED3_u6784"><a href="#u6A21_u5F0F_u7684_u7ED3_u6784" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol>
<li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li>
<li>具体主题（Concrete  Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，<strong>当接到具体主题的更改通知时被调用。</strong></li>
<li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li>
</ol>
<p>观察者模式的结构图如图所示。</p>
<p><img src="/2019/11/26/观察者模式/3-1Q1161A6221S.gif" alt="观察者模式的结构图"></p>
<h3 id="u6A21_u5F0F_u7684_u5B9E_u73B0"><a href="#u6A21_u5F0F_u7684_u5B9E_u73B0" class="headerlink" title="模式的实现"></a>模式的实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers=<span class="keyword">new</span> ArrayList&lt;Observer&gt;();   </span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体目标发生改变..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);       </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(Object obs:observers)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Observer)obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体观察者1作出反应！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体观察者2作出反应！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">package</span> observer;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Subject subject=<span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer obs1=<span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">        Observer obs2=<span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>（1）定义抽象目标接口，增加或删除观察者；需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者。</p>
<p>（2）定义具体目标接口，继承抽象目标接口，通知观察者们自己发生了改变。</p>
<p>（3）定义抽象观察者接口，需要对通知做出反应。</p>
<p>（4）定义具体观察者接口，不同的观察者根据通知内容作出不同的反应。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为型模式</category>
      </categories>
  </entry>
  <entry>
    <title>结构型模式总结</title>
    <url>/2019/11/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
  </entry>
  <entry>
    <title>结构型模式之装饰模式</title>
    <url>/2019/11/26/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等。在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰模式来实现。</p>
<h2 id="u88C5_u9970_u6A21_u5F0F_u7684_u5B9A_u4E49_u4E0E_u7279_u70B9"><a href="#u88C5_u9970_u6A21_u5F0F_u7684_u5B9A_u4E49_u4E0E_u7279_u70B9" class="headerlink" title="装饰模式的定义与特点"></a>装饰模式的定义与特点</h2><p>装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰（Decorator）模式的主要优点有：</p>
<ul>
<li>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</li>
<li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li>
</ul>
<p>其主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>
<h2 id="u88C5_u9970_u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0"><a href="#u88C5_u9970_u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0" class="headerlink" title="装饰模式的结构与实现"></a>装饰模式的结构与实现</h2><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但<strong>继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀</strong>。如果==使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。== </p>
<h3 id="u6A21_u5F0F_u7684_u7ED3_u6784"><a href="#u6A21_u5F0F_u7684_u7ED3_u6784" class="headerlink" title="模式的结构"></a>模式的结构</h3><p>装饰模式主要包含以下角色。</p>
<ol>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ol>
<p>装饰模式的结构图如图所示。</p>
<p><img src="/2019/11/26/装饰模式/3-1Q115142115M2.gif" alt="装饰模式的结构图"></p>
<h3 id="u6A21_u5F0F_u7684_u5B9E_u73B0"><a href="#u6A21_u5F0F_u7684_u5B9E_u73B0" class="headerlink" title="模式的实现"></a>模式的实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建具体构件角色"</span>);       </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用具体构件角色的方法operation()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component=component;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为具体构件角色增加额外的功能addedFunction()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">package</span> decorator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component p=<span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        Component d=<span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u88C5_u9970_u6A21_u5F0F_u7684_u5E94_u7528_u573A_u666F"><a href="#u88C5_u9970_u6A21_u5F0F_u7684_u5E94_u7528_u573A_u666F" class="headerlink" title="装饰模式的应用场景"></a>装饰模式的应用场景</h2><p>装饰模式在 Java语言中的最著名的应用莫过于 Java I/O 标准库的设计了。</p>
<p>例如，<strong>InputStream 的子类 FilterInputStream</strong>，OutputStream 的子类 FilterOutputStream，<strong>Reader 的子类 BufferedReader 以及 FilterReader</strong>，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</p>
<p> 为 FileReader 增加缓冲区而采用的装饰类 BufferedReader 的例子： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"filename.txtn));</span></span><br><span class="line"><span class="string">String s=in.readLine();</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/26/装饰模式/decorator-3-1574749946934.png" alt="decorator-3"></p>
<h2 id="u8865_u5145"><a href="#u8865_u5145" class="headerlink" title="补充"></a>补充</h2><p>装饰模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如以下两种情况。</p>
<p>(1) 如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件。</p>
<p>(2) 如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p> 从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。 </p>
</blockquote>
<p><img src="/2019/11/26/装饰模式/3-1Q115142115M2.gif" alt="装饰模式的结构图"></p>
<p><img src="/2019/11/26/装饰模式/decorator-2-1574749886994.png" alt="decorator-2"></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
  </entry>
  <entry>
    <title>结构型模式之适配器模式</title>
    <url>/2019/11/25/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。</p>
<p>在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题</p>
<h2 id="u9002_u914D_u5668_u6A21_u5F0F_u7684_u5B9A_u4E49_u4E0E_u7279_u70B9"><a href="#u9002_u914D_u5668_u6A21_u5F0F_u7684_u5B9A_u4E49_u4E0E_u7279_u70B9" class="headerlink" title="适配器模式的定义与特点"></a>适配器模式的定义与特点</h2><p>适配器模式（Adapter）的定义如下：==将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。==适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>该模式的主要优点如下。</p>
<ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
</ul>
<p>其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。</p>
<h2 id="u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0"><a href="#u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<h3 id="u6A21_u5F0F_u7684_u7ED3_u6784"><a href="#u6A21_u5F0F_u7684_u7ED3_u6784" class="headerlink" title="模式的结构"></a>模式的结构</h3><p>适配器模式（Adapter）包含以下主要角色。</p>
<ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，<strong>把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</strong></li>
</ol>
<p>类适配器模式的结构图如下图所示。</p>
<p><img src="/2019/11/25/适配器模式/3-1Q1151045351c.gif" alt="类适配器模式的结构图"></p>
<p>对象适配器模式的结构图如下图所示。</p>
<p><img src="/2019/11/25/适配器模式/3-1Q1151046105A.gif" alt="对象适配器模式的结构图"></p>
<h3 id="u6A21_u5F0F_u7684_u5B9E_u73B0"><a href="#u6A21_u5F0F_u7684_u5B9E_u73B0" class="headerlink" title="模式的实现"></a>模式的实现</h3><p>(1) 类适配器模式的代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">"适配者中的业务代码被调用！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapterTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类适配器模式测试："</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)对象适配器模式的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口(发动机)</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者1（电能发动机）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">"适配者中的业务代码被调用！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象适配器类（电能适配器）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;（）</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapterTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对象适配器模式测试："</span>);</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Target target = <span class="keyword">new</span> ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>记住，适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，<strong>把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</strong></p>
<p>对象适配器：</p>
<p><img src="/2019/11/25/适配器模式/adapter-1.png" alt="adapter-1"></p>
<p>类适配和对象适配的异同</p>
<blockquote>
<p>一个采用继承，一个采用组合；</p>
<p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p>
<p>总体来说，对象适配用得比较多。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
  </entry>
  <entry>
    <title>结构型模式之代理模式</title>
    <url>/2019/11/25/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。</p>
<p>在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。</p>
<h2 id="u4EE3_u7406_u6A21_u5F0F_u7684_u5B9A_u4E49_u4E0E_u7279_u70B9"><a href="#u4EE3_u7406_u6A21_u5F0F_u7684_u5B9A_u4E49_u4E0E_u7279_u70B9" class="headerlink" title="代理模式的定义与特点"></a>代理模式的定义与特点</h2><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>代理模式的主要优点有：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
<p>其主要缺点是：</p>
<ul>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
</ul>
<h2 id="u4EE3_u7406_u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0"><a href="#u4EE3_u7406_u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0" class="headerlink" title="代理模式的结构与实现"></a>代理模式的结构与实现</h2><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问。</p>
<h3 id="u6A21_u5F0F_u7684_u7ED3_u6784"><a href="#u6A21_u5F0F_u7684_u7ED3_u6784" class="headerlink" title="模式的结构"></a>模式的结构</h3><p>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</p>
<p>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</p>
<p>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</p>
<p>其结构图如下：</p>
<p><img src="/2019/11/25/代理模式/3-1Q115093011523.gif" alt="代理模式的结构图"></p>
<h3 id="u6A21_u5F0F_u7684_u5B9E_u73B0"><a href="#u6A21_u5F0F_u7684_u5B9E_u73B0" class="headerlink" title="模式的实现"></a>模式的实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题方法..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject=<span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();<span class="comment">//核心代码是真实主题类做的</span></span><br><span class="line">        postRequest();</span><br><span class="line">        <span class="comment">//代理只是在核心代码前后做”无足轻重”的事情</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之前的预处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之后的后续处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Proxy proxy=<span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</p>
<p>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，（ 可以看java.lang.reflect.Proxy 类的源码）；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p>
<h2 id="u9644_uFF1A_u4EE3_u7406_u6A21_u5F0F_u548C_u4E2D_u4ECB_u8005_u6A21_u5F0F_u533A_u522B"><a href="#u9644_uFF1A_u4EE3_u7406_u6A21_u5F0F_u548C_u4E2D_u4ECB_u8005_u6A21_u5F0F_u533A_u522B" class="headerlink" title="附：代理模式和中介者模式区别"></a>附：代理模式和中介者模式区别</h2><p><strong>代理模式（Proxy Pattern）</strong><br>用一个代理类代表另一个类的功能，但是不改变被代理类的功能。目的是控制对被代理类的访问。</p>
<p><strong>中介者模式（Mediator Pattern）</strong><br>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。将各对象之间的网状结构分离为星型结构。<br>例如：MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。微信群是各群员之间的中介者。</p>
<p>参考: <a href="https://javadoop.com/post/design-pattern" target="_blank" rel="noopener">https://javadoop.com/post/design-pattern</a> </p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
  </entry>
  <entry>
    <title>创建型模式总结</title>
    <url>/2019/11/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>创建型模式的主要关注点是“怎样创建对象？”，它这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p>
<p> 创建型模式分为以下几种。 </p>
<ul>
<li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li><del>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</del></li>
<li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
</ul>
<p>以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式。</p>
<blockquote>
<p>单例模式为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；</p>
<p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；</p>
<p>抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。</p>
<p>建造者模式专门对付属性很多的那种类，为了让代码更优美；</p>
</blockquote>
<p>参考: <a href="http://c.biancheng.net/view/1335.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1335.html</a> </p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型模式之建造者模式</title>
    <url>/2019/11/25/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由CPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。</p>
<p>以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。</p>
<h2 id="u5EFA_u9020_u8005_u6A21_u5F0F_u7684_u5B9A_u4E49_u4E0E_u7279_u70B9"><a href="#u5EFA_u9020_u8005_u6A21_u5F0F_u7684_u5B9A_u4E49_u4E0E_u7279_u70B9" class="headerlink" title="建造者模式的定义与特点"></a>建造者模式的定义与特点</h2><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<p>该模式的主要优点如下：</p>
<ol>
<li>各个具体的建造者相互独立，有利于系统的扩展。</li>
<li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li>
</ol>
<p>其缺点如下：</p>
<ol>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li>
</ol>
<p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而更注重零部件的创建过程，但两者可以结合使用。</p>
<h2 id="u5EFA_u9020_u8005_u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0"><a href="#u5EFA_u9020_u8005_u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0" class="headerlink" title="建造者模式的结构与实现"></a>建造者模式的结构与实现</h2><p>建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成，</p>
<h3 id="u6A21_u5F0F_u7684_u7ED3_u6784"><a href="#u6A21_u5F0F_u7684_u7ED3_u6784" class="headerlink" title="模式的结构"></a>模式的结构</h3><p>建造者（Builder）模式的主要角色如下。</p>
<ol>
<li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。</li>
<li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li>
<li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li>
<li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li>
</ol>
<p>其结构图</p>
<p><img src="/2019/11/25/建造者模式/3-1Q1141H441X4.gif" alt="建造者模式的结构图"></p>
<h3 id="u6A21_u5F0F_u7684_u5B9E_u73B0"><a href="#u6A21_u5F0F_u7684_u5B9E_u73B0" class="headerlink" title="模式的实现"></a>模式的实现</h3><p>(1) 产品角色：包含多个组成部件的复杂对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA=partA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartB</span><span class="params">(String partB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partB=partB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartC</span><span class="params">(String partC)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partC=partC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> (2) 抽象建造者：包含创建产品各个子部件的抽象方法。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> Product product=<span class="keyword">new</span> Product();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> (3) 具体建造者：实现了抽象建造者接口。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">"建造 PartA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">"建造 PartB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">"建造 PartC"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> (4) 指挥者：调用建造者中的方法完成复杂对象的创建。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder=builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> (5) 客户类。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Builder builder=<span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director=<span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product=director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4E2A_u4EBA_u7406_u89E3"><a href="#u4E2A_u4EBA_u7406_u89E3" class="headerlink" title="个人理解"></a>个人理解</h2><p>比如建造一个客厅（产品），客厅有沙发，墙纸，电视（多个组件），现在客户把客厅的建造要求告诉给包工头（指挥者），包工头先抽象出建造者需要建造哪些组件（抽象建造者），然后指挥具体的工人（具体建造者）去建造，最后包工头将建造好的结果返回给客户。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
  </entry>
  <entry>
    <title>创建型模式之抽象工厂模式</title>
    <url>/2019/11/24/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。</p>
<p>同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。 </p>
<p> 抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族。</p>
<h2 id="u62BD_u8C61_u5DE5_u5382_u6A21_u5F0F_u7684_u5B9A_u4E49_u4E0E_u7279_u70B9"><a href="#u62BD_u8C61_u5DE5_u5382_u6A21_u5F0F_u7684_u5B9A_u4E49_u4E0E_u7279_u70B9" class="headerlink" title="抽象工厂模式的定义与特点"></a>抽象工厂模式的定义与特点</h2><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。 </p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li><p>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</p>
<p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下 </p>
</li>
<li><p>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</p>
</li>
<li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li>
</ul>
<p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<h2 id="u62BD_u8C61_u5DE5_u5382_u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0"><a href="#u62BD_u8C61_u5DE5_u5382_u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0" class="headerlink" title="抽象工厂模式的结构与实现"></a>抽象工厂模式的结构与实现</h2><p>抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。 </p>
<p>主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象产品：饮料</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Drink</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品：零食</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Food</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体饮料：矿泉水</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Water</span> <span class="keyword">implements</span> <span class="title">Drink</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"矿泉水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体饮料：可乐</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Coke</span> <span class="keyword">implements</span> <span class="title">Drink</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"可乐"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体零食：面包</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Bread</span> <span class="keyword">implements</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"面包"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体零食：面条</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Noodles</span> <span class="keyword">implements</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"面条"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂：提供了产品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drink <span class="title">creatDrink</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">creatFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：三只松鼠，实现了产品的生成方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drink <span class="title">creatDrink</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体工厂 1 生成--&gt;具体产品 11..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Water();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">creatFood</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体工厂 1 生成--&gt;具体产品 21..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Coke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂：百草园，实现了产品的生成方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drink <span class="title">creatDrink</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体工厂 1 生成--&gt;具体产品 11..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Water();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">creatFood</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体工厂 1 生成--&gt;具体产品 21..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Coke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建零食售卖机（具体工厂），</span></span><br><span class="line">        ConcreteFactory1 factory1 = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">        <span class="comment">//获取矿泉水与面包（具体产品）</span></span><br><span class="line">        factory1.createDrink().show();</span><br><span class="line">        factory1.createFood().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p><strong>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例</strong>。</p>
<p>参考： <a href="https://www.jianshu.com/p/d951ac56136e" target="_blank" rel="noopener">https://www.jianshu.com/p/d951ac56136e</a> </p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
  </entry>
  <entry>
    <title>创建型模式之工厂模式</title>
    <url>/2019/11/24/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p> 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 </p>
<h2 id="u5DE5_u5382_u6A21_u5F0F_u7684_u5B9A_u4E49_u548C_u7279_u70B9"><a href="#u5DE5_u5382_u6A21_u5F0F_u7684_u5B9A_u4E49_u548C_u7279_u70B9" class="headerlink" title="工厂模式的定义和特点"></a>工厂模式的定义和特点</h2><p>工厂方法（FactoryMethod）模式的定义：<strong>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。</strong>（这满足创建型模式中所要求的“创建与使用相分离”的特点。)</p>
<p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。 <strong>如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”</strong>，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。</p>
<p> “工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。 </p>
<p>优点：</p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li>
</ul>
<p>缺点：</p>
<ul>
<li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 </li>
</ul>
<h2 id="u5DE5_u5382_u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0"><a href="#u5DE5_u5382_u6A21_u5F0F_u7684_u7ED3_u6784_u4E0E_u5B9E_u73B0" class="headerlink" title="工厂模式的结构与实现"></a>工厂模式的结构与实现</h2><h3 id="1_u3001_u7B80_u5355_u5DE5_u5382_u6A21_u5F0F"><a href="#1_u3001_u7B80_u5355_u5DE5_u5382_u6A21_u5F0F" class="headerlink" title="1、简单工厂模式"></a>1、简单工厂模式</h3><p>又叫静态工厂方法模式。是由一个工厂对象决定创建出哪一种产品类的实例。实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。 </p>
<p><strong>结构</strong></p>
<p>主要角色：</p>
<ol>
<li>具体工厂：负责实现创建所有实例的内部逻辑，并提供一个外界调用的方法，创建所需的产品对象。</li>
<li>抽象产品：负责描述产品的公共接口</li>
<li>具体产品：描述生产的具体产品。 </li>
</ol>
<p><strong>实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1</span> <span class="keyword">implements</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品1显示..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2</span> <span class="keyword">implements</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品2显示..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品3：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product3</span> <span class="keyword">implements</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品3显示..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂：生产不同的商品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">makeProduct</span><span class="params">(String type)</span></span>&#123;       </span><br><span class="line">      <span class="keyword">if</span>(Type.equalsIgnoreCase(<span class="string">"product1"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Product1();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Type.equalsIgnoreCase(<span class="string">"product2"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Product2();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Type.equalsIgnoreCase(<span class="string">"product3"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Product3();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建具体的工厂</span></span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">        <span class="comment">//根据传入的参数生产不同的产品实例</span></span><br><span class="line">        Product1 A = Factory.getProduct(<span class="string">"product1"</span>);</span><br><span class="line">        A.show();</span><br><span class="line">        Product2 B = Factory.getProduct(<span class="string">"product1"</span>);</span><br><span class="line">        B.show();</span><br><span class="line">        Product3 C = Factory.getProduct(<span class="string">"product1"</span>);</span><br><span class="line">        C.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5DE5_u5382_u65B9_u6CD5_u6A21_u5F0F"><a href="#u5DE5_u5382_u65B9_u6CD5_u6A21_u5F0F" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>主要角色如下：</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建，供外界调用 。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，描述生产的具体产品。由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<p><img src="/2019/11/24/工厂模式/3-1Q114135A2M3.gif" alt="工厂方法模式的结构图"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1</span> <span class="keyword">implements</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品1显示..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2</span> <span class="keyword">implements</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品2显示..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂：提供了商品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">makeProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂1：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">makeProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//"具体工厂1负责生成--&gt;具体产品1;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂2：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory2</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">makeProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//具体工厂2负责生成--&gt;具体产品2;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建具体的工厂</span></span><br><span class="line">        Factory1 factory1 = <span class="keyword">new</span> Factory1();</span><br><span class="line">        <span class="comment">//生产相对应的产品</span></span><br><span class="line">        factory1.makeProduct().show();</span><br><span class="line">        Factory2 factory2 = <span class="keyword">new</span> Factory2();</span><br><span class="line">        factory2.makeProduct().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>简单工厂模式： <strong>一个抽象产品类，可以派生出多个具体产品类。一个具体工厂类，通过往此工厂的static方法中传入不同参数，产出不同的具体产品类实例。</strong> </p>
<p>工厂方法模式： <strong>一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例</strong>。 </p>
<p>参考： <a href="https://www.jianshu.com/p/d951ac56136e" target="_blank" rel="noopener">https://www.jianshu.com/p/d951ac56136e</a> </p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>创建型模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型模式之单例模式</title>
    <url>/2019/11/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。</p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h2 id="u5355_u4F8B_u6A21_u5F0F_u7684_u7ED3_u6784"><a href="#u5355_u4F8B_u6A21_u5F0F_u7684_u7ED3_u6784" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h2><p>这里举例饿汉式。</p>
<p>创建一个SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。并提供了一个静态方法，供外界获取它的静态实例。</p>
<ul>
<li><strong>第一步：</strong>创建一个SingleObject类。</li>
</ul>
<blockquote>
<p>SingleObject.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;    <span class="comment">//创建 SingleObject 的一个对象</span></span><br><span class="line">&gt;    <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line">&gt;  </span><br><span class="line">&gt;    <span class="comment">//让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">&gt;    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;    <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;       <span class="keyword">return</span> instance;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;       System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>第二步</strong>： 从 singleton 类获取唯一的对象。 </li>
</ul>
<p>SingletonPatternDemo.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPatternDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//不合法的构造函数</span></span><br><span class="line">   <span class="comment">//编译时错误：构造函数 SingleObject() 是不可见的</span></span><br><span class="line">   <span class="comment">//SingleObject object = new SingleObject();</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">   SingleObject object = SingleObject.getInstance();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//显示消息</span></span><br><span class="line">   object.showMessage();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>第三步</strong>：执行程序输出结果：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u51E0_u79CD_u5B9E_u73B0_u65B9_u5F0F"><a href="#u51E0_u79CD_u5B9E_u73B0_u65B9_u5F0F" class="headerlink" title="几种实现方式"></a>几种实现方式</h2><h3 id="1_u3001_u61D2_u6C49_u5F0F"><a href="#1_u3001_u61D2_u6C49_u5F0F" class="headerlink" title="1、懒汉式"></a>1、懒汉式</h3><h4 id="u7EBF_u7A0B_u4E0D_u5B89_u5168"><a href="#u7EBF_u7A0B_u4E0D_u5B89_u5168" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>特点：类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。 (延迟初始化)</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">     instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="keyword">return</span> instance;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u7EBF_u7A0B_u5B89_u5168"><a href="#u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="线程安全"></a>线程安全</h4><p>特点：避免内存浪费，必须加锁 synchronized 才能保证单例，但效率很低。 </p>
<p>使用场景： getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 </p>
<blockquote>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">&gt;     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">&gt;     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">&gt;     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">&gt;         instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;     <span class="keyword">return</span> instance;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2_u3001_u997F_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168"><a href="#2_u3001_u997F_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="2、饿汉式，线程安全"></a>2、饿汉式，线程安全</h3><p> 特点：类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。  这种方式比较常用，因为没有加锁，所以执行效率会提高，但容易产生垃圾对象。 </p>
<blockquote>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span></span></span><br><span class="line"><span class="class">&gt; </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance=<span class="keyword">new</span> HungrySingleton();</span><br><span class="line">&gt;     <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;     </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> instance;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3_u3001_u9759_u6001_u5185_u90E8_u7C7B"><a href="#3_u3001_u9759_u6001_u5185_u90E8_u7C7B" class="headerlink" title="3、静态内部类"></a>3、静态内部类</h3><blockquote>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">&gt;     <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">&gt;     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">&gt;     <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>1、懒汉式与饿汉式的根本区别在与是否在<strong>类内方法外</strong>创建自己的对象。并且<strong>声明对象都需要私有化，构造方法都要私有化</strong>，这样外部才不能通过 new 对象的方式来访问。饿汉式是声明并创建对象(因为他饿)，懒汉式只是声明对象，在调用该类的 getinstance() 方法时才会进行 new 对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>创建型模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>在SpringBoot中生成Mybatis逆向文件</title>
    <url>/2019/11/20/Java%E5%90%8E%E7%AB%AF/MyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1_u3001pom-xml_u914D_u7F6E"><a href="#1_u3001pom-xml_u914D_u7F6E" class="headerlink" title="1、pom.xml配置"></a>1、pom.xml配置</h2><p>在pom.xml文件中，需要进行如下配置。</p>
<p>==这里需要注意一下，一开始添加<code>mybatis-generator-core</code>可能无法导入，需要先在上面的dependencies中先添加，让其下载，然后在剪切到这里。==</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入plugin(插件)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       	<span class="comment">&lt;!--1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--2--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>mybatis generator<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--允许移动生成的文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--允许自动覆盖文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">            src/main/resources/mybatis-generator.xml</span><br><span class="line">        <span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2__u3001_u6570_u636E_u5E93_u64CD_u4F5C"><a href="#2__u3001_u6570_u636E_u5E93_u64CD_u4F5C" class="headerlink" title="2 、数据库操作"></a>2 、数据库操作</h2><p>新建数据库：</p>
<p><img src="/2019/11/20/Java后端/MyBatis逆向工程/1566868749472.png" alt="1566868749472"></p>
<p>建立表结构</p>
<ul>
<li>user-info表</li>
</ul>
<p><img src="/2019/11/20/Java后端/MyBatis逆向工程/1566869200183.png" alt="1566869200183"></p>
<ul>
<li>user-password表</li>
</ul>
<p><img src="/2019/11/20/Java后端/MyBatis逆向工程/1566873521746.png" alt="1566873521746"></p>
<p>新建两个包:dao以及dataobject，为后面配置mybatis-generator.xml做准备。</p>
<p><img src="/2019/11/20/Java后端/MyBatis逆向工程/1566873616460.png" alt="1566873616460"></p>
<h2 id="3_u3001_u914D_u7F6E_u9006_u5411_u5DE5_u7A0B_u6587_u4EF6"><a href="#3_u3001_u914D_u7F6E_u9006_u5411_u5DE5_u7A0B_u6587_u4EF6" class="headerlink" title="3、配置逆向工程文件"></a>3、配置逆向工程文件</h2><p>新建mybatis-generator.xml，并进行配置。</p>
<p>注意，在配置<code>jdbcConnection</code>时：</p>
<ul>
<li>==driverClass的驱动需要注意，和过去版本不一样，这里配的mysql版本是8.0.15==</li>
<li>==connectionURL注意时间问题，否则会报错。（或者修改mysql数据库时区）==</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"MysqlTables"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是；false:否 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码,这里配置的是mysql的，当然也可以配置oracle等数据库，注意连接地址中的时间问题 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/miaosha?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">"root123"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--数据库类型和java类型的控制转换--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer;为true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--生成DataObject(Pojo)类包名和存放位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.miaoshaproject.dataobject"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 生成Mapper映射XML文件存放位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapping"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/resources"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--生成Dao类(Mapper接口)文件存放位置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件的代码</span></span><br><span class="line"><span class="comment">                type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象</span></span><br><span class="line"><span class="comment">                type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象</span></span><br><span class="line"><span class="comment">                type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"com.miaoshaproject.dao"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成对应表及类名(更改tableName和domainObjectName就可以)--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName:要生成的表名</span></span><br><span class="line"><span class="comment">        domainObjectName:生成后的实例名</span></span><br><span class="line"><span class="comment">        enableCountByExample:Count语句中加入where条件查询，默认为true开启</span></span><br><span class="line"><span class="comment">        enableUpdateByExample:Update语句中加入where条件查询，默认为true开启</span></span><br><span class="line"><span class="comment">        enableDeleteByExample:Delete语句中加入where条件查询，默认为true开启</span></span><br><span class="line"><span class="comment">        enableSelectByExample:Select多条语句中加入where条件查询，默认为true开启</span></span><br><span class="line"><span class="comment">        selectByExampleQueryId:Select单个对象语句中加入where条件查询，默认为true开启</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"user_info"</span> <span class="attr">domainObjectName</span>=<span class="string">"UserDO"</span>  <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"user_password"</span> <span class="attr">domainObjectName</span>=<span class="string">"UserPasswordDO"</span> <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4_u3001_u8FD0_u884Cmaven_u547D_u4EE4"><a href="#4_u3001_u8FD0_u884Cmaven_u547D_u4EE4" class="headerlink" title="4、运行maven命令"></a>4、运行maven命令</h2><p>在run按钮下找到edit configuration，新建maven并配置maven命令：<code>mybatis-generator:generate</code>。</p>
<p><img src="/2019/11/20/Java后端/MyBatis逆向工程/1566869870436.png" alt="1566869870436"></p>
<h2 id="5_u3001_u5220_u9664_u5E26Example_u7684_u6587_u4EF6"><a href="#5_u3001_u5220_u9664_u5E26Example_u7684_u6587_u4EF6" class="headerlink" title="5、删除带Example的文件"></a>5、删除带Example的文件</h2>]]></content>
      <categories>
        <category>项目学习</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot构建电商项目</title>
    <url>/2019/11/19/Java%E5%90%8E%E7%AB%AF/SpringBoot%20%E6%9E%84%E5%BB%BA%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="u4E00_u3001_u7B80_u4ECB"><a href="#u4E00_u3001_u7B80_u4ECB" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1_u3001Spring_Boot_u7B80_u4ECB"><a href="#1_u3001Spring_Boot_u7B80_u4ECB" class="headerlink" title="1、Spring Boot简介"></a>1、Spring Boot简介</h2><p>SpringBoot不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包。SpringBoot整合了所有的框架，并通过一行简单的main方法启动应用。</p>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566804291827.png" alt="1566804291827"></p>
<h2 id="2_u3001_u7535_u5546_u79D2_u6740_u5E94_u7528_u7B80_u4ECB"><a href="#2_u3001_u7535_u5546_u79D2_u6740_u5E94_u7528_u7B80_u4ECB" class="headerlink" title="2、电商秒杀应用简介"></a>2、电商秒杀应用简介</h2><ul>
<li>商品列表页获取秒杀商品列表</li>
<li>进入商品详情页获取秒杀商品详情</li>
<li>秒杀开始后进入下单确认页下单并支付成功</li>
</ul>
<h1 id="u4E8C_u3001_u9879_u76EE_u5B9E_u6218"><a href="#u4E8C_u3001_u9879_u76EE_u5B9E_u6218" class="headerlink" title="二、项目实战"></a>二、项目实战</h1><h2 id="1_u3001_u4F7F_u7528IDEA+Maven_u642D_u5EFASpringBoot_u5F00_u53D1_u73AF_u5883"><a href="#1_u3001_u4F7F_u7528IDEA+Maven_u642D_u5EFASpringBoot_u5F00_u53D1_u73AF_u5883" class="headerlink" title="1、使用IDEA+Maven搭建SpringBoot开发环境"></a>1、使用IDEA+Maven搭建SpringBoot开发环境</h2><h3 id="1_u3001_u9879_u76EE_u521B_u5EFA_u6D41_u7A0B"><a href="#1_u3001_u9879_u76EE_u521B_u5EFA_u6D41_u7A0B" class="headerlink" title="1、项目创建流程"></a>1、项目创建流程</h3><p>1、点击maven，使用quickstart，点击next。</p>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566805402859.png" alt="1566805402859"></p>
<p>2、命名，点击next</p>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566805516324.png" alt="1566805516324"></p>
<p>3、继续点击next，进入下面页面</p>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566805565590.png" alt="1566805565590"></p>
<p>4、点击Finish，完成创建。</p>
<p>5、设置项目根目录</p>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566805897601.png" alt="1566805897601"></p>
<p>6、设置test root</p>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566806099127.png" alt="1566806099127"></p>
<p>7、设置resource root（需要先创建resources文件夹）</p>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566806031455.png" alt="1566806031455"></p>
<p>8、项目目录结构</p>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566806265031.png" alt="1566806265031"></p>
<h3 id="2_u3001_u914D_u7F6E_u6587_u4EF6"><a href="#2_u3001_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><p><a href="https://spring.io/guides/gs/rest-service/" target="_blank" rel="noopener">springboot官网</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;name&gt;miaosha&lt;/name&gt;</span><br><span class="line">&lt;!-- FIXME change it to the project&apos;s website --&gt;</span><br><span class="line">&lt;url&gt;http://www.example.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--放置在url下面--&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//引入web开发的依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置数据库mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--配置连接池管理数据库连接--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--springboot对mybatis的支持--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，刷新maven工程下载jar包。</p>
<h2 id="2_u3001_u96C6_u6210MyBaits_u64CD_u4F5C_u6570_u636E_u5E93"><a href="#2_u3001_u96C6_u6210MyBaits_u64CD_u4F5C_u6570_u636E_u5E93" class="headerlink" title="2、集成MyBaits操作数据库"></a>2、集成MyBaits操作数据库</h2><p>springboot对应的配置化的操作在resources文件目录下创建默认的配置：application.properties，然后在该文件中进行配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mybatis.mapper-locations=classpath:mapping/*.xml</span><br></pre></td></tr></table></figure>
<p>然后在resources下创建mapping文件夹。</p>
<p>接下来使用mybatis自动生成工具用来生成数据库对应的映射。</p>
<h3 id="1_u3001mybaits-generator_u81EA_u52A8_u751F_u6210_u5DE5_u5177_uFF08_u91CD_u70B9_uFF09"><a href="#1_u3001mybaits-generator_u81EA_u52A8_u751F_u6210_u5DE5_u5177_uFF08_u91CD_u70B9_uFF09" class="headerlink" title="1、mybaits-generator自动生成工具（重点）"></a>1、mybaits-generator自动生成工具（重点）</h3><p>在pom.xml文件中，需要进行如下配置。</p>
<p>==这里需要注意一下，一开始添加<code>mybatis-generator-core</code>可能无法导入，需要现在上面的dependencies中先添加，让其下载，然后在剪切到这里。==</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入plugin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>mybatis generator<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--允许移动生成的文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--允许自动覆盖文件，实际工作中不可以--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">            src/main/resources/mybatis-generator.xml</span><br><span class="line">        <span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>新建数据库：</p>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566868749472.png" alt="1566868749472"></p>
<p>建立表结构</p>
<ul>
<li>user-info表</li>
</ul>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566869200183.png" alt="1566869200183"></p>
<ul>
<li>user-password表</li>
</ul>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566873521746.png" alt="1566873521746"></p>
<p>新建两个包:dao(对数据库的操作)以及dataobject（数据库表字段），为后面配置mybatis-generator.xml做准备。</p>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566873616460.png" alt="1566873616460"></p>
<p>配置mybatis-generator.xml。</p>
<p>注意，在配置<code>jdbcConnection</code>时：</p>
<ul>
<li>==driverClass的驱动需要注意，和过去版本不一样，这里配的mysql版本是8.0.15==</li>
<li>==connectionURL注意时间问题，否则会报错）（或者修改mysql数据库时区）==</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"MysqlTables"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是；false:否 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码,这里配置的是mysql的，当然也可以配置oracle等数据库，注意连接地址中的时间问题 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/miaosha?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">"root123"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--数据库类型和java类型的控制转换--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer;为true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--生成DataObject(Pojo)类包名和存放位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.miaoshaproject.dataobject"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 生成Mapper映射XML文件存放位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapping"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/resources"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--生成Dao类(Mapper接口)文件存放位置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件的代码</span></span><br><span class="line"><span class="comment">                type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象</span></span><br><span class="line"><span class="comment">                type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象</span></span><br><span class="line"><span class="comment">                type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"com.miaoshaproject.dao"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成对应表及类名(更改tableName和domainObjectName就可以)--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName:要生成的表名</span></span><br><span class="line"><span class="comment">        domainObjectName:生成后的实例名</span></span><br><span class="line"><span class="comment">        enableCountByExample:Count语句中加入where条件查询，默认为true开启</span></span><br><span class="line"><span class="comment">        enableUpdateByExample:Update语句中加入where条件查询，默认为true开启</span></span><br><span class="line"><span class="comment">        enableDeleteByExample:Delete语句中加入where条件查询，默认为true开启</span></span><br><span class="line"><span class="comment">        enableSelectByExample:Select多条语句中加入where条件查询，默认为true开启</span></span><br><span class="line"><span class="comment">        selectByExampleQueryId:Select单个对象语句中加入where条件查询，默认为true开启</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"user_info"</span> <span class="attr">domainObjectName</span>=<span class="string">"UserDO"</span>  <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"user_password"</span> <span class="attr">domainObjectName</span>=<span class="string">"UserPasswordDO"</span> <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在run按钮下找到edit configuration新建maven并配置maven命令：</p>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1566869870436.png" alt="1566869870436"></p>
<p>删除带example的文件。</p>
<h3 id="2_u3001_u914D_u7F6Eapplication-properties"><a href="#2_u3001_u914D_u7F6Eapplication-properties" class="headerlink" title="2、配置application.properties"></a>2、配置application.properties</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port=8090</span><br><span class="line">mybatis.mapper-locations=classpath:mapping/*.xml</span><br><span class="line"></span><br><span class="line">#添加的如下配置：</span><br><span class="line">spring.datasource.name=miaoshao</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/miaosha?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root123</span><br><span class="line"></span><br><span class="line">#使用druid数据源</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<h2 id="3_u3001_u57FA_u7840_u80FD_u529B_u5EFA_u8BBE"><a href="#3_u3001_u57FA_u7840_u80FD_u529B_u5EFA_u8BBE" class="headerlink" title="3、基础能力建设"></a>3、基础能力建设</h2><h3 id="1_u3001service_u5C42"><a href="#1_u3001service_u5C42" class="headerlink" title="1、service层"></a>1、service层</h3><p>新建service包，在该包下新建UserService接口以及其实现类，</p>
<p>UserService类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.service.model.UserModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过用户ID获取用户的对象的方法</span></span><br><span class="line">    <span class="function">UserModel <span class="title">getUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserServiceImpl类：本项目在该类下实现了两个方法，目的是将从数据库中的user表和password表放到一起，并存放到UserModel中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.dao.UserDOMapper;</span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.dao.UserPasswordDOMapper;</span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.dataobject.UserDO;</span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.dataobject.UserPasswordDO;</span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.service.model.UserModel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDOMapper userDOMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserPasswordDOMapper userPasswordDOMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//从数据库获取用户信息和密码并返回到UserModel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserModel <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用userdomapper获取到对应的用户dataobject</span></span><br><span class="line">        UserDO userDO = userDOMapper.selectByPrimaryKey(id);</span><br><span class="line">        <span class="keyword">if</span>(userDO == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过用户id获取对应的用户加密密码信息</span></span><br><span class="line">        UserPasswordDO userPasswordDO = userPasswordDOMapper.selectByUserId(userDO.getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> convertFromDataObject(userDO,userPasswordDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将用户信息和密码存放到UserModel中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserModel <span class="title">convertFromDataObject</span><span class="params">(UserDO userDO, UserPasswordDO userPasswordDO)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userDO == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserModel userModel = <span class="keyword">new</span> UserModel();</span><br><span class="line">        BeanUtils.copyProperties(userDO,userModel);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(userPasswordDO!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            userModel.setEncrptPassword(userPasswordDO.getEncrptPassword());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在企业级应用中，UserDO是不能传给前端的。UserDO(对应数据库映射)-&gt;UserModel(service层)-&gt;UserVO(controller层)</strong></p>
<p>UserModel类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.service.model;</span><br><span class="line"></span><br><span class="line"><span class="comment">//领域模型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Byte gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String telphone;</span><br><span class="line">    <span class="keyword">private</span> String registerMode;</span><br><span class="line">    <span class="keyword">private</span> String thirdPartyId;</span><br><span class="line">    <span class="keyword">private</span> String encrptPassword;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get，set方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2_u3001controller_u5C42"><a href="#2_u3001controller_u5C42" class="headerlink" title="2、controller层"></a>2、controller层</h3><p>和service层类似，新建controller包，并创建UserController类和UserVO类（这个类的作用类似于UserModel类）</p>
<p>UserController类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.controller.viewobject.UserVO;</span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.error.BusinessException;</span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.error.EmBussinessError;</span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.response.CommonReturnType;</span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.service.model.UserModel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getUser</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span> Integer id) <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">        <span class="comment">//调用service服务获取对应id的用户对象并返回给前端</span></span><br><span class="line">        UserModel userModel = userService.getUserById(id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//若获取的对应用户信息不存在</span></span><br><span class="line">        <span class="keyword">if</span> (userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBussinessError.USER_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将核心领域对象模型用户对象转化为可供ui使用的viewobject</span></span><br><span class="line">        UserVO userVO = converFromModel(userModel);</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(userVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> UserVO <span class="title">converFromModel</span><span class="params">(UserModel userModel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserVO userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">        BeanUtils.copyProperties(userModel, userVO);</span><br><span class="line">        <span class="keyword">return</span> userVO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserVO类：只向前端展示部分信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.controller.viewobject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Byte gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String telphone;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//set，get方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BaseController类：基类。注意一下该类的HanlderException方法：向前端展示固定的响应信息（错误码，错误信息）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.error.BusinessException;</span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.error.EmBussinessError;</span><br><span class="line"><span class="keyword">import</span> com.miaoshaproject.response.CommonReturnType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义exceptionhandler解决未被controller层吸收的exception</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.OK)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handlerException</span><span class="params">(HttpServletRequest request, Exception ex)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">            BusinessException businessException = (BusinessException) ex;</span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, businessException.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>, businessException.getErrMsg());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, EmBussinessError.UNKNOWN_ERROR.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>, EmBussinessError.UNKNOWN_ERROR.getErrMsg());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(responseData, <span class="string">"fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3_u3001response_u5305"><a href="#3_u3001response_u5305" class="headerlink" title="3、response包"></a>3、response包</h3><p>CommonReturnType：在该类下定义了向前端响应信息的固定格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReturnType</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表明对应请求的返回处理结果“success”或“fail”</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若status=success，则data内返回前端需要的json数据</span></span><br><span class="line">    <span class="comment">//若status=fail，则data内使用通用的错误码格式</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个通用的创建方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(result,<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result,String status)</span></span>&#123;</span><br><span class="line">        CommonReturnType type = <span class="keyword">new</span> CommonReturnType();</span><br><span class="line">        type.setStatus(status);</span><br><span class="line">        type.setData(result);</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4_u3001error_u5305"><a href="#4_u3001error_u5305" class="headerlink" title="4、error包"></a>4、error包</h3><p>实现对错误信息的封装。</p>
<h4 id="1_u3001_u5B9A_u4E49CommonError_u63A5_u53E3_uFF0C"><a href="#1_u3001_u5B9A_u4E49CommonError_u63A5_u53E3_uFF0C" class="headerlink" title="1、定义CommonError接口，"></a>1、定义CommonError接口，</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2_u3001_u5B9E_u73B0_u8BE5_u63A5_u53E3_uFF1A_u81EA_u5B9A_u4E49_u9519_u8BEF_u548C_u7CFB_u7EDF_u5F02_u5E38"><a href="#2_u3001_u5B9E_u73B0_u8BE5_u63A5_u53E3_uFF1A_u81EA_u5B9A_u4E49_u9519_u8BEF_u548C_u7CFB_u7EDF_u5F02_u5E38" class="headerlink" title="2、实现该接口：自定义错误和系统异常"></a>2、实现该接口：自定义错误和系统异常</h4><ul>
<li>EmBusinessError类：自定义异常，枚举类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EmBussinessError implements CommonError&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通用错误类型00001</span></span><br><span class="line">    PARAMETER_VALIDATION_ERROR(<span class="number">10001</span>,<span class="string">"参数不合法"</span>),</span><br><span class="line">    UNKNOWN_ERROR(<span class="number">10002</span>,<span class="string">"未知错误"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//10000开头为用户信息相关错误定义</span></span><br><span class="line">    USER_NOT_EXIST(<span class="number">20001</span>,<span class="string">"用户不存在"</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EmBussinessError</span><span class="params">(<span class="keyword">int</span> errCode,String errMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errCode=errCode;</span><br><span class="line">        <span class="keyword">this</span>.errMsg = errMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errCode;</span><br><span class="line">    <span class="keyword">private</span> String errMsg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.errMsg=errorMsg;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>系统异常，继承Exception类</li>
</ul>
<p>BusinessException类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.error;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//包装器业务异常类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessException</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">implements</span> <span class="title">CommonError</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CommonError commonError;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接接收EmBusinessError的传参用于构造业务异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError=commonError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受自定义errMsg的方式构造业务异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError,String errMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError=commonError;</span><br><span class="line">        <span class="keyword">this</span>.commonError.setErrorMsg(errMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.commonError.getErrCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.commonError.getErrMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.commonError.setErrorMsg(errorMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：首先定义一个CommonReturnType，能够用对应的status和data返回所有json序列化的固定的对象供前端解析使用，摒弃掉了用httpservlet自带的statuscode加内嵌tomcat 的自带的error页去处理，并且我们定义了commonbusinesserror去统一的管理所想要的错误码，然后要做的是在basecontroller里面定义了一个通用的exceptionhandler类来解决未被controller层吸收的exception。</p>
<h2 id="4_u3001_u6A21_u578B_u80FD_u529B_u7BA1_u7406_uFF08_u53C2_u7167_u4EE3_u7801_uFF09"><a href="#4_u3001_u6A21_u578B_u80FD_u529B_u7BA1_u7406_uFF08_u53C2_u7167_u4EE3_u7801_uFF09" class="headerlink" title="4、模型能力管理（参照代码）"></a>4、模型能力管理（参照代码）</h2><p>==先设计领域模型，再设计表。先用mybatis-generator生成mapper.xml-&gt;service-&gt;serviceImp-&gt;controller==</p>
<h3 id="1_u3001_u7528_u6237_u6A21_u5757_u5F00_u53D1"><a href="#1_u3001_u7528_u6237_u6A21_u5757_u5F00_u53D1" class="headerlink" title="1、用户模块开发"></a>1、用户模块开发</h3><h4 id="1_u3001otp_u77ED_u4FE1_u83B7_u53D6_uFF08otp_uFF1A_u7ED9_u7528_u6237_u53D1_u77ED_u4FE1_u544A_u8BC9_u9A8C_u8BC1_u7801_uFF09"><a href="#1_u3001otp_u77ED_u4FE1_u83B7_u53D6_uFF08otp_uFF1A_u7ED9_u7528_u6237_u53D1_u77ED_u4FE1_u544A_u8BC9_u9A8C_u8BC1_u7801_uFF09" class="headerlink" title="1、otp短信获取（otp：给用户发短信告诉验证码）"></a>1、otp短信获取（otp：给用户发短信告诉验证码）</h4><h4 id="2_u3001otp_u6CE8_u518C_u7528_u6237"><a href="#2_u3001otp_u6CE8_u518C_u7528_u6237" class="headerlink" title="2、otp注册用户"></a>2、otp注册用户</h4><h4 id="3_u3001_u7528_u6237_u624B_u673A_u767B_u9646"><a href="#3_u3001_u7528_u6237_u624B_u673A_u767B_u9646" class="headerlink" title="3、用户手机登陆"></a>3、用户手机登陆</h4><h4 id="4_u3001_u6570_u636E_u6821_u9A8C"><a href="#4_u3001_u6570_u636E_u6821_u9A8C" class="headerlink" title="4、数据校验"></a>4、数据校验</h4><h3 id="2_u3001_u5546_u54C1_u6A21_u5757_u5F00_u53D1"><a href="#2_u3001_u5546_u54C1_u6A21_u5757_u5F00_u53D1" class="headerlink" title="2、商品模块开发"></a>2、商品模块开发</h3><h4 id="1_u3001_u5546_u54C1_u521B_u5EFA"><a href="#1_u3001_u5546_u54C1_u521B_u5EFA" class="headerlink" title="1、商品创建"></a>1、商品创建</h4><h4 id="2_u3001_u5546_u54C1_u5217_u8868_u83B7_u53D6"><a href="#2_u3001_u5546_u54C1_u5217_u8868_u83B7_u53D6" class="headerlink" title="2、商品列表获取"></a>2、商品列表获取</h4><h4 id="3_u3001_u5546_u54C1_u8BE6_u60C5_u9875_u9762"><a href="#3_u3001_u5546_u54C1_u8BE6_u60C5_u9875_u9762" class="headerlink" title="3、商品详情页面"></a>3、商品详情页面</h4><h3 id="3_u3001_u4EA4_u6613_u6A21_u5757_u5F00_u53D1"><a href="#3_u3001_u4EA4_u6613_u6A21_u5757_u5F00_u53D1" class="headerlink" title="3、交易模块开发"></a>3、交易模块开发</h3><h4 id="1_u3001_u4EA4_u6613_u6A21_u578B_u521B_u5EFA"><a href="#1_u3001_u4EA4_u6613_u6A21_u578B_u521B_u5EFA" class="headerlink" title="1、交易模型创建"></a>1、交易模型创建</h4><h4 id="2_u3001_u4EA4_u6613_u4E0B_u5355"><a href="#2_u3001_u4EA4_u6613_u4E0B_u5355" class="headerlink" title="2、交易下单"></a>2、交易下单</h4><h3 id="4_u3001_u79D2_u6740_u6A21_u5757_u5F00_u53D1"><a href="#4_u3001_u79D2_u6740_u6A21_u5757_u5F00_u53D1" class="headerlink" title="4、秒杀模块开发"></a>4、秒杀模块开发</h3><h4 id="1_u3001_u6D3B_u52A8_u6A21_u578B_u521B_u5EFA"><a href="#1_u3001_u6D3B_u52A8_u6A21_u578B_u521B_u5EFA" class="headerlink" title="1、活动模型创建"></a>1、活动模型创建</h4><h4 id="2_u3001_u6D3B_u52A8_u6A21_u578B_u4E0E_u5546_u54C1_u6A21_u578B_u76F8_u7ED3_u5408"><a href="#2_u3001_u6D3B_u52A8_u6A21_u578B_u4E0E_u5546_u54C1_u6A21_u578B_u76F8_u7ED3_u5408" class="headerlink" title="2、活动模型与商品模型相结合"></a>2、活动模型与商品模型相结合</h4><h1 id="u8BFE_u7A0B_u603B_u7ED3"><a href="#u8BFE_u7A0B_u603B_u7ED3" class="headerlink" title="课程总结"></a>课程总结</h1><ul>
<li>学会使用SpringBoot+mybatis完成JavaWeb项目的搭建</li>
<li>学会一个电商秒杀系统的基本流程及代码实现</li>
</ul>
<p>1、使用前后端分离的方式在前端的ui完成了页面的展示</p>
<p>2、在接入层使用了springmvc 的controller定义了view object返回通用对象和通用异常处理</p>
<p>3、业务层使用了对应的mybatis的接入以及model层领域模型的概念完成的相关核心服务的业务层并且使用了transactional的标签完成事务的切面</p>
<p>4、数据库：mysql，缓存，本地缓存，集中式缓存redis</p>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1567390685847.png" alt="1567390685847"></p>
<h2 id="1_u3001_u51FA_u9519_u8C03_u8BD5"><a href="#1_u3001_u51FA_u9519_u8C03_u8BD5" class="headerlink" title="1、出错调试"></a>1、出错调试</h2><ul>
<li>先确定问题点：环境问题，ui展示问题，接口问题，服务问题，配置问题</li>
<li>调试：断点调试，日志调试</li>
<li>互联网寻找答案</li>
</ul>
<h2 id="2_u3001_u8D44_u6E90"><a href="#2_u3001_u8D44_u6E90" class="headerlink" title="2、资源"></a>2、资源</h2><ul>
<li>Metronic框架：基于bootstrap的付费ui模版</li>
<li>视频代码内容：跟着老师的思路打一遍，融会贯通原理</li>
</ul>
<h2 id="3_u3001_u62D3_u5C55_u601D_u7EF4"><a href="#3_u3001_u62D3_u5C55_u601D_u7EF4" class="headerlink" title="3、拓展思维"></a>3、拓展思维</h2><ul>
<li>多商品，多库存，多活动模型怎么实现？</li>
</ul>
<h2 id="4_u3001_u9057_u7559_u95EE_u9898"><a href="#4_u3001_u9057_u7559_u95EE_u9898" class="headerlink" title="4、遗留问题"></a>4、遗留问题</h2><ul>
<li>如何支撑亿级秒杀流量？</li>
</ul>
<p><img src="/2019/11/19/Java后端/SpringBoot 构建电商项目/1567391267113.png" alt="1567391267113"></p>
<p>参照慕课网<a href="https://www.imooc.com/learn/1079" target="_blank" rel="noopener">SpringBoot构建电商基础秒杀项目</a></p>
]]></content>
      <categories>
        <category>项目学习</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找细节</title>
    <url>/2019/11/19/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h1 id="u4E8C_u5206_u67E5_u627E_u6846_u67B6"><a href="#u4E8C_u5206_u67E5_u627E_u6846_u67B6" class="headerlink" title="二分查找框架"></a>二分查找框架</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1_u3001_u5BFB_u627E_u4E00_u4E2A_u6570_uFF08_u57FA_u672C_u7684_u4E8C_u5206_u641C_u7D22_uFF09"><a href="#1_u3001_u5BFB_u627E_u4E00_u4E2A_u6570_uFF08_u57FA_u672C_u7684_u4E8C_u5206_u641C_u7D22_uFF09" class="headerlink" title="1、寻找一个数（基本的二分搜索）"></a>1、寻找一个数（基本的二分搜索）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2_u3001_u5BFB_u627E_u5DE6_u4FA7_u8FB9_u754C_u7684_u4E8C_u5206_u641C_u7D22"><a href="#2_u3001_u5BFB_u627E_u5DE6_u4FA7_u8FB9_u754C_u7684_u4E8C_u5206_u641C_u7D22" class="headerlink" title="2、寻找左侧边界的二分搜索"></a>2、寻找左侧边界的二分搜索</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">left_binarySearch</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left =<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid= left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            left =mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left==nums.length) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// 注意！！！</span></span><br><span class="line">    <span class="keyword">return</span> nums[left]==target?left:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3_u3001_u5BFB_u627E_u53F3_u4FA7_u8FB9_u754C_u7684_u4E8C_u5206_u641C_u7D22"><a href="#3_u3001_u5BFB_u627E_u53F3_u4FA7_u8FB9_u754C_u7684_u4E8C_u5206_u641C_u7D22" class="headerlink" title="3、寻找右侧边界的二分搜索"></a>3、寻找右侧边界的二分搜索</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">right_binarysearch</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left =<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid =left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left =mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//注意！！！</span></span><br><span class="line">    <span class="keyword">return</span> nums[right]==target?right:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int left=0，right=nums.length-1;</span><br><span class="line">while(lefg&lt;=right)</span><br><span class="line">left = mid + 1;</span><br><span class="line">right = mid - 1;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>算法，二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot入门(一)工程搭建</title>
    <url>/2019/11/18/Java%E5%90%8E%E7%AB%AF/SpringBoot%E5%85%A5%E9%97%A8(%E4%B8%80)%E5%B7%A5%E7%A8%8B%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="SpringBoot_u5165_u95E8"><a href="#SpringBoot_u5165_u95E8" class="headerlink" title="SpringBoot入门"></a>SpringBoot入门</h1><h2 id="SpringBoot_u7B80_u4ECB"><a href="#SpringBoot_u7B80_u4ECB" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><blockquote>
<p>简化Spring应用开发的一个框架；</p>
<p>整个Spring技术栈的一个大整合；</p>
<p>J2EE开发的一站式解决方案；</p>
</blockquote>
<p>官网：<a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">springboot</a></p>
<h2 id="u5FAE_u670D_u52A1"><a href="#u5FAE_u670D_u52A1" class="headerlink" title="微服务"></a>微服务</h2><blockquote>
<p>2014，martin fowler</p>
<p>微服务：架构风格（服务微化）</p>
<p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p>
<p>单体应用：ALL IN ONE</p>
<p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p>
</blockquote>
<p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" target="_blank" rel="noopener">详细参照微服务文档</a></p>
<h1 id="SpringBoot_u5DE5_u7A0B_u642D_u5EFA"><a href="#SpringBoot_u5DE5_u7A0B_u642D_u5EFA" class="headerlink" title="SpringBoot工程搭建"></a>SpringBoot工程搭建</h1><p>本篇是对springboot项目快速搭建，创建maven工程看<a href>springboot构建电商项目</a></p>
<h2 id="u521B_u5EFA_u9879_u76EE"><a href="#u521B_u5EFA_u9879_u76EE" class="headerlink" title="创建项目"></a>创建项目</h2><p>1、 选择Spring Initializr，并选择本地的JDK版本（默认即可），点击Next。</p>
<p><img src="/2019/11/18/Java后端/SpringBoot入门(一)工程快速搭建/SpringBoot入门(一" alt="image-20191119100751312">工程快速搭建/image-20191119100751312.png)</p>
<p>2、对项目进行命名，工程名字要全小写，artifact填写项目名，package填写包名，完成点击Next。</p>
<p><img src="/2019/11/18/Java后端/SpringBoot入门(一)工程快速搭建/SpringBoot入门(一" alt="image-20191119101044453">工程快速搭建/image-20191119101044453.png)</p>
<p>3、选择项目依赖，为了快速搭建，这里选web项目，点击Next。</p>
<p><img src="/2019/11/18/Java后端/SpringBoot入门(一)工程快速搭建/SpringBoot入门(一" alt="image-20191119101345975">工程快速搭建/image-20191119101345975.png)</p>
<p>解释：</p>
<p><code>Developer Tool</code>: SpringBoot提供的热部署插件，可以避免每次修改代码都要重新启动项目。</p>
<p><code>lomback</code>: 使用Lomback减少项目中很多重复代码的书写。具体参考：<a href="https://blog.csdn.net/motui/article/details/79012846" target="_blank" rel="noopener">lomback介绍</a></p>
<p><code>Thymeleaf</code>: 语法的支持</p>
<p>以上依赖非必选，如果仅仅想尝试一下Spring Boot-HelloWorld，只需要选择其中的<code>web</code>依赖即可。</p>
<p>4、最后点击Finish，完成创建。</p>
<p><img src="/2019/11/18/Java后端/SpringBoot入门(一)工程快速搭建/SpringBoot入门(一" alt="image-20191119101839298">工程快速搭建/image-20191119101839298.png)</p>
<h2 id="u9879_u76EE_u51C6_u5907"><a href="#u9879_u76EE_u51C6_u5907" class="headerlink" title="项目准备"></a>项目准备</h2><p>1、删除不必要文件</p>
<p><img src="/2019/11/18/Java后端/SpringBoot入门(一)工程快速搭建/SpringBoot入门(一" alt="image-20191119102145044">工程快速搭建/image-20191119102145044.png)</p>
<p>2、设置根目录。（用模版创建的已经设置好了，还是记录一下）</p>
<ul>
<li>设置项目根目录，java</li>
</ul>
<p><img src="/2019/11/18/Java后端/SpringBoot入门(一)工程快速搭建/SpringBoot入门(一" alt="1566805897601">工程快速搭建/1566805897601.png)</p>
<ul>
<li>设置test root</li>
</ul>
<p><img src="/2019/11/18/Java后端/SpringBoot入门(一)工程快速搭建/SpringBoot入门(一" alt="1566806099127">工程快速搭建/1566806099127.png)</p>
<ul>
<li>设置resource root</li>
</ul>
<p><img src="/2019/11/18/Java后端/SpringBoot入门(一)工程快速搭建/SpringBoot入门(一" alt="1566806031455">工程快速搭建/1566806031455.png)</p>
<p>3、项目结构</p>
<p><img src="/2019/11/18/Java后端/SpringBoot入门(一)工程快速搭建/SpringBoot入门(一" alt="image-20191119103016919">工程快速搭建/image-20191119103016919.png)</p>
<p><strong>resources文件夹中目录结构</strong></p>
<ul>
<li>static：保存所有的静态资源； js css  images；</li>
<li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li>
<li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li>
</ul>
<h3 id="u95EE_u9898_u89E3_u91CA"><a href="#u95EE_u9898_u89E3_u91CA" class="headerlink" title="问题解释"></a>问题解释</h3><p>1、 为什么没有XML？</p>
<p>答：回顾传统Spring项目，我们需要先后配置web/spring/mvc等XML配置文件。而SpringBoot则不需要XML，只需借助注解和启动类就能启动项目。这背后得益于SpringBoot自动配置的构建原理，例如我们在POM文件引入了Web依赖，则<strong>项目在启动的时候检测到ClassPath存在Web依赖，就会自动执行WEB环境初始化，轻松完成SpringMVC初始化。</strong></p>
<p>2、为什么没有webapp目录？</p>
<p>答：SpringBoot使用Resources目录放置静态文件和动态资源。比如static目录可以直接读取CSS/JS/IMG等静态资源，而templates目录可以直接读取动态模板，例如Thymeleaf 和 FreeMarker 等。不过值得注意的是，如果工程项使用War类型进行打包，则必须创建webapp目录，更多细节请戳<a href="https://www.jianshu.com/p/6dcfe16d91d0" target="_blank" rel="noopener">《SpringBoot 工程结构说明》</a></p>
<p>3、application.properties / application.yml 是什么？</p>
<p>答：这是SpringBoot项目的核心配置文件，更多细节请阅读<a href="https://www.jianshu.com/p/60b34464ca58" target="_blank" rel="noopener">《SpringBoot 配置文件详解 》</a>。</p>
<p>4、 SpringbootApplication.java是什么？</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，仅是一个简单的main方法，其中最核心的就是<code>@SpringBootApplication</code>注解，</p>
<p><code>@SpringBootApplication</code>: Spring Boot应用标注在某个类上说明这个类是SpringBoot的<strong>主配置类</strong>，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p>它是以下三个注解的总和：</p>
<ol>
<li><code>@Configuration</code>: 用于定义一个配置类。 配置类也是容器中的一个组件；@Component。</li>
<li><code>@EnableAutoConfiguration</code>: 开启自动配置功能。 SpringBoot会自动根据你的jar包依赖来自动配置项目。 </li>
<li><code>@ComponentScan</code>: 告诉Spring哪个packages的用注解标识的类会被Spring自动扫描并且转入Bean容器。 例如@Controller,@Service等. </li>
</ol>
<p>通过以上三个注解你就应该了解到了SpringBoot的作用：自动化配置项目。之前我们要手动进行的XML配置在这里仅需要这一个注解就完成了。且SpringBoot项目不需要单独部署到Tomcat中才能启动，通过这个启动器，SpringBoot会自动构建一个web容器，并将项目部署到其中。</p>
<h3 id="pom_u4F9D_u8D56_u7BA1_u7406"><a href="#pom_u4F9D_u8D56_u7BA1_u7406" class="headerlink" title="pom依赖管理"></a>pom依赖管理</h3><p>如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!------------------1、继承SpringBoot父工程---------------------------------&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hycoder<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-------2、启动器，帮我们导入web模块正常运行所依赖的组件，包括Tomcat和SpringMVC。----&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!---------------- Test支持 -----------------------------------------&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-------- 这个插件，可以将应用打包成一个可执行的jar包；--------------------------&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="u542F_u52A8_u9879_u76EE"><a href="#u542F_u52A8_u9879_u76EE" class="headerlink" title="启动项目"></a>启动项目</h2><p>编写一个Controller类进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动SpringbootApplication.java，在网页输入localhost:8080/hello：</p>
<p><img src="/2019/11/18/Java后端/SpringBoot入门(一)工程快速搭建/SpringBoot入门(一" alt="image-20191119141734606">工程快速搭建/image-20191119141734606.png)</p>
<p>成功运行。</p>
<p>参考博客：</p>
<p><a href="https://tycoding.cn/2018/09/28/boot/spring-boot/" target="_blank" rel="noopener">https://tycoding.cn/2018/09/28/boot/spring-boot/</a> </p>
<p><a href="https://www.jianshu.com/p/17e0e55c88db" target="_blank" rel="noopener">https://www.jianshu.com/p/17e0e55c88db</a> </p>
]]></content>
      <categories>
        <category>后端框架</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/2019/11/17/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<h2 id="01_u3001_u4E8C_u7EF4_u6570_u7EC4_u4E2D_u7684_u67E5_u627E_uFF08_u70ED_u95E8_uFF09"><a href="#01_u3001_u4E8C_u7EF4_u6570_u7EC4_u4E2D_u7684_u67E5_u627E_uFF08_u70ED_u95E8_uFF09" class="headerlink" title="01、二维数组中的查找（热门）"></a>01、二维数组中的查找（热门）</h2><h3 id="u9898_u76EE_u63CF_u8FF0"><a href="#u9898_u76EE_u63CF_u8FF0" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<blockquote>
<p>matrix = [<br>    [1,2,3]<br>    [4,5,6]<br>    [7,8,9]<br>]</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF"><a href="#u89E3_u9898_u601D_u8DEF" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>从右上角或左下角开始找，逐行排除。</strong></p>
<h3 id="u4EE3_u7801_u5B9E_u73B0"><a href="#u4EE3_u7801_u5B9E_u73B0" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[][] array, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、首先判断数组是否为空，是则返回false</span></span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//2、定义行和列，即查找的方式</span></span><br><span class="line">    <span class="keyword">int</span> row =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col =array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//3、循环查找</span></span><br><span class="line">    <span class="keyword">while</span>(row&lt;array.length &amp;&amp; col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[row][col] == number)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[row][col] &gt; number)&#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：array.length返回的二维数组的行的长度，array[i].length返回的是第i行的长度。</p>
<h2 id="02_u3001_u66FF_u6362_u7A7A_u683C_uFF08_u70ED_u95E8_uFF09"><a href="#02_u3001_u66FF_u6362_u7A7A_u683C_uFF08_u70ED_u95E8_uFF09" class="headerlink" title="02、替换空格（热门）"></a>02、替换空格（热门）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-1"><a href="#u9898_u76EE_u63CF_u8FF0-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-1"><a href="#u89E3_u9898_u601D_u8DEF-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>使用StringBuffer或者StringBuilder从前往后复制字符串。</strong></p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-1"><a href="#u4EE3_u7801_u5B9E_u73B0-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、如果字符串为空，返回null</span></span><br><span class="line">    	<span class="keyword">if</span>(str == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//2、定义StringBuffer</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//3、for循环遍历字符串，使用append替换空格</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.toString().length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(String.valueOf(str.charAt(i)).equals(<span class="string">" "</span>))&#123;</span><br><span class="line">                sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//结果转换成String类型并返回</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="03_u3001_u4ECE_u5C3E_u5230_u5934_u6253_u5370_u94FE_u8868_uFF08_u70ED_u95E8_uFF09"><a href="#03_u3001_u4ECE_u5C3E_u5230_u5934_u6253_u5370_u94FE_u8868_uFF08_u70ED_u95E8_uFF09" class="headerlink" title="03、从尾到头打印链表（热门）"></a>03、从尾到头打印链表（热门）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-2"><a href="#u9898_u76EE_u63CF_u8FF0-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-2"><a href="#u89E3_u9898_u601D_u8DEF-2" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>利用栈来实现；</strong></p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-2"><a href="#u4EE3_u7801_u5B9E_u73B0-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个链表</span></span><br><span class="line"><span class="keyword">public</span> Class ListNode&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next =<span class="keyword">null</span>;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val =val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、定义返回的list</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//2、如果链表为空，则返回list</span></span><br><span class="line">    <span class="keyword">if</span>(listNode == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">    <span class="comment">//3、定义栈</span></span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//4、遍历链表放入栈中</span></span><br><span class="line">    <span class="keyword">while</span> (listNode !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(listNode);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5、出栈</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        list.add(stack.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="04_u3001_u91CD_u5EFA_u4E8C_u53C9_u6811_uFF08_u70ED_u95E8_uFF09"><a href="#04_u3001_u91CD_u5EFA_u4E8C_u53C9_u6811_uFF08_u70ED_u95E8_uFF09" class="headerlink" title="04、重建二叉树（热门）"></a>04、重建二叉树（热门）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-3"><a href="#u9898_u76EE_u63CF_u8FF0-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-3"><a href="#u89E3_u9898_u601D_u8DEF-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>前序遍历：根左右</p>
<p>中序遍历：左根右</p>
<p><strong>先找根节点，再递归构建。</strong></p>
<p>前序遍历的第一个节点就是树的根节点，所以我们先根据前序遍历序列的第一个数字创建根结点，接下来在中序遍历序列中找到根结点的位置，根节点的左边就是左子树，右边就是右子树，这样就能确定左、右子树结点的数量。在前序遍历和中序遍历的序列中划分了左、右子树结点的值之后，就可以递归地去分别构建它的左右子树。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-3"><a href="#u4EE3_u7801_u5B9E_u73B0-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一颗二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、前序和中序如果长度为0或者不等，返回null</span></span><br><span class="line">    <span class="keyword">if</span>(pre.length==<span class="number">0</span>||in.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre.length != in.length) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、定义根节点：为前序遍历的第一个数</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//3、遍历前序数组，在中序遍历中找到根节点，划分左右子树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[<span class="number">0</span>] == in[i]) &#123;</span><br><span class="line">            root.left = reConstructBinaryTree(</span><br><span class="line">                Arrays.copyOfRange(pre,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,i));</span><br><span class="line">            root.right = reConstructBinaryTree(     Arrays.copyOfRange(pre,i+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,i+<span class="number">1</span>,in.length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="05_u3001_u7528_u4E24_u4E2A_u6808_u5B9E_u73B0_u961F_u5217_uFF08_u70ED_u95E8_uFF09"><a href="#05_u3001_u7528_u4E24_u4E2A_u6808_u5B9E_u73B0_u961F_u5217_uFF08_u70ED_u95E8_uFF09" class="headerlink" title="05、用两个栈实现队列（热门）"></a>05、用两个栈实现队列（热门）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-4"><a href="#u9898_u76EE_u63CF_u8FF0-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-4"><a href="#u89E3_u9898_u601D_u8DEF-4" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>两个栈 stack1 和 stack2:</strong></p>
<ul>
<li><strong>push 动作都在 stack1 中进行，</strong></li>
<li><strong>pop 动作在 stack2 中进行。当 stack2 不为空时，直接 pop，当 stack2 为空时，先把 stack1 中的元素 pop 出来，push 到 stack2 中，再从 stack2 中 pop 元素。</strong></li>
</ul>
<h3 id="u5B9E_u73B0_u4EE3_u7801"><a href="#u5B9E_u73B0_u4EE3_u7801" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、定义两个栈</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、push操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、pop操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="06_u3001_u65CB_u8F6C_u6570_u7EC4_u7684_u6700_u5C0F_u6570_u5B57_uFF08_u540CLeetCode153_uFF0C154_uFF09"><a href="#06_u3001_u65CB_u8F6C_u6570_u7EC4_u7684_u6700_u5C0F_u6570_u5B57_uFF08_u540CLeetCode153_uFF0C154_uFF09" class="headerlink" title="06、旋转数组的最小数字（同LeetCode153，154）"></a>06、旋转数组的最小数字（同LeetCode153，154）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-5"><a href="#u9898_u76EE_u63CF_u8FF0-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-5"><a href="#u89E3_u9898_u601D_u8DEF-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以认为数组分成了两部分，前半部分是<strong>较大的数</strong>，后半部分是<strong>较小的数</strong>。</p>
<p>利用二分查找的思路，观察<strong>取中的数</strong>在前半部分还是后半部分，以此来找出最小的数（后半部分的第一个数）。</p>
<p><strong>注意：</strong></p>
<ul>
<li><strong>循环条件为：left&lt;right</strong></li>
<li><strong>right=mid;left=mid+1。若high=mid-1会产生错误。</strong></li>
<li><strong>return left,right都可以</strong></li>
</ul>
<h3 id="u4EE3_u7801_u5B9E_u73B0-4"><a href="#u4EE3_u7801_u5B9E_u73B0-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、判断数组大小是否为0</span></span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//2、二分查找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right =array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid =left +(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&gt;array[right])</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、返回左边界结果</span></span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="07_u3001_u6590_u6CE2_u90A3_u5951_u6570_u5217_uFF08_u70ED_u95E8_uFF09"><a href="#07_u3001_u6590_u6CE2_u90A3_u5951_u6570_u5217_uFF08_u70ED_u95E8_uFF09" class="headerlink" title="07、斐波那契数列（热门）"></a>07、斐波那契数列（热门）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-6"><a href="#u9898_u76EE_u63CF_u8FF0-6" class="headerlink" title="题目描述"></a>题目描述</h3><p> 现在要求输入一个整数n，请你输出斐波那契数列的第n项（<strong>从0开始，第0项为0</strong>）。n&lt;=39</p>
<blockquote>
<p>公式:<br>f(n) = n, n &lt;= 1<br>f(n) = f(n-1) + f(n-2), n &gt; 1</p>
<p>f~0~=0，f~1~=1，f~2~=1，f~3~=2，f~4~=3,…,fn=f~n-2~+f~n-1~</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-6"><a href="#u89E3_u9898_u601D_u8DEF-6" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>注意：这里求得是第n项的值，而不是前n项的值。</strong></p>
<ul>
<li><strong>动态规划</strong></li>
<li>递归，效率太低</li>
</ul>
<h3 id="u4EE3_u7801_u5B9E_u73B0-5"><a href="#u4EE3_u7801_u5B9E_u73B0-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">1</span>) <span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">0</span>,f2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            result =f1+f2;</span><br><span class="line">            f1=f2;</span><br><span class="line">            f2=result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>衍生题</p>
<ul>
<li>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</li>
</ul>
<p>这题与上题有点区别，不是从0层开始：</p>
<p>第一层：1—&gt;f2</p>
<p>第二层：1+1=2—&gt;f3；</p>
<p>第三层：2+1=3—&gt;f4;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">1</span>,f2=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            result=f1+f2;</span><br><span class="line">            f1=f2;</span><br><span class="line">            f2=result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一只青蛙一次可以跳上1级台阶，也可以跳上2级……<strong>它也可以跳上n级。</strong>求该青蛙跳上一个n级的台阶总共有多少种跳法。（2^(n-1)^）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(target == <span class="number">0</span> || target == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(target == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target; i ++) &#123;<span class="comment">//本次跳0次到跳target-1次</span></span><br><span class="line">			sum += JumpFloorII(i);<span class="comment">//对于本次的跳跃又有多少种跳法？递归获取结果</span></span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？(斐波那契思想,和跳台阶代码一样)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">1</span>,f2=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            result=f1+f2;</span><br><span class="line">            f1=f2;</span><br><span class="line">            f2=result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11_u3001_u4E8C_u8FDB_u5236_u4E2D1_u7684_u4E2A_u6570_uFF08_u70ED_u95E8_uFF09"><a href="#11_u3001_u4E8C_u8FDB_u5236_u4E2D1_u7684_u4E2A_u6570_uFF08_u70ED_u95E8_uFF09" class="headerlink" title="11、二进制中1的个数（热门）"></a>11、二进制中1的个数（热门）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-7"><a href="#u9898_u76EE_u63CF_u8FF0-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-7"><a href="#u89E3_u9898_u601D_u8DEF-7" class="headerlink" title="解题思路"></a>解题思路</h3><p><a href="https://www.cnblogs.com/sakurayj/p/10253911.html" target="_blank" rel="noopener">参考：原码，反码，补码</a></p>
<p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。<br>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-6"><a href="#u4EE3_u7801_u5B9E_u73B0-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            count+=<span class="number">1</span>;</span><br><span class="line">            n&amp;=(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12_u3001_u6570_u503C_u7684_u6574_u6570_u6B21_u65B9_uFF08_u6CA1_u505A_uFF09"><a href="#12_u3001_u6570_u503C_u7684_u6574_u6570_u6B21_u65B9_uFF08_u6CA1_u505A_uFF09" class="headerlink" title="12、数值的整数次方（没做）"></a>12、数值的整数次方（没做）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-8"><a href="#u9898_u76EE_u63CF_u8FF0-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。不得使用库函数，不需要考虑大数问题。</p>
<h2 id="13_u3001_u8C03_u6574_u6570_u7EC4_u987A_u5E8F_u4F7F_u5947_u6570_u4F4D_u4E8E_u5076_u6570_u524D_u9762_uFF08_u5F85_u5B8C_u5584_uFF09"><a href="#13_u3001_u8C03_u6574_u6570_u7EC4_u987A_u5E8F_u4F7F_u5947_u6570_u4F4D_u4E8E_u5076_u6570_u524D_u9762_uFF08_u5F85_u5B8C_u5584_uFF09" class="headerlink" title="13、调整数组顺序使奇数位于偶数前面（待完善）"></a>13、调整数组顺序使奇数位于偶数前面（待完善）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-9"><a href="#u9898_u76EE_u63CF_u8FF0-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-8"><a href="#u89E3_u9898_u601D_u8DEF-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法一：</p>
<p>使用额外空间，复制原数组，找到放置偶数的起始下标。</p>
<p>方法二：</p>
<p>使用双指针。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-7"><a href="#u4EE3_u7801_u5B9E_u73B0-7" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>方法一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderArray</span><span class="params">(<span class="keyword">int</span>[] ints)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oddnums=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:ints) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">            oddnums++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] copy = ints.clone();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=oddnums;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:copy)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">            ints[i] = num;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ints[j]=num;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14_u3001_u94FE_u8868_u4E2D_u5012_u6570_u7B2Ck_u4E2A_u8282_u70B9_28_u4E00_u822C_29"><a href="#14_u3001_u94FE_u8868_u4E2D_u5012_u6570_u7B2Ck_u4E2A_u8282_u70B9_28_u4E00_u822C_29" class="headerlink" title="14、链表中倒数第k个节点(一般)"></a>14、链表中倒数第k个节点(一般)</h2><h3 id="u9898_u76EE_u63CF_u8FF0-10"><a href="#u9898_u76EE_u63CF_u8FF0-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-9"><a href="#u89E3_u9898_u601D_u8DEF-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>倒数第k个结点，即第n-k+1结点</p>
<p>==快慢指针==，定义两个指针，定义两个指针slow和fast，使他们都指向第一个结点。到第 n-k+1 个结点则需要移动 n-k次。</p>
<p>此时，fast移动n次会指向空。先让fast移动 k 次，还剩 n-k 次指向空。</p>
<p>这时，slow与fast同步移动，当fast指空时，node移动了 n-k 次，刚好到第 n-k+1 个结点</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-8"><a href="#u4EE3_u7801_u5B9E_u73B0-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>||k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15_u3001_u53CD_u8F6C_u94FE_u8868_uFF08_u4E00_u822C_uFF09"><a href="#15_u3001_u53CD_u8F6C_u94FE_u8868_uFF08_u4E00_u822C_uFF09" class="headerlink" title="15、反转链表（一般）"></a>15、反转链表（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-11"><a href="#u9898_u76EE_u63CF_u8FF0-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-10"><a href="#u89E3_u9898_u601D_u8DEF-10" class="headerlink" title="解题思路"></a>解题思路</h3><p>设置两个指针，pre为当前节点的前一个节点，next为当前节点的下一个节点</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-9"><a href="#u4EE3_u7801_u5B9E_u73B0-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre =<span class="keyword">null</span>;</span><br><span class="line">        ListNode next =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            next =head.next; <span class="comment">//next为当前节点的下一个结点</span></span><br><span class="line">            head.next=pre; <span class="comment">//将当前结点的下一个节点指向前一个结点,（进行反转）</span></span><br><span class="line">            pre = head; <span class="comment">//pre记录当前结点，即下一个结点的前一个结点</span></span><br><span class="line">            head =next; <span class="comment">//将当前结改为下一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16_u3001_u5408_u5E76_u4E24_u4E2A_u6392_u5E8F_u7684_u94FE_u8868_uFF08_u9012_u5F52_uFF0C_u7B80_u5355_uFF09"><a href="#16_u3001_u5408_u5E76_u4E24_u4E2A_u6392_u5E8F_u7684_u94FE_u8868_uFF08_u9012_u5F52_uFF0C_u7B80_u5355_uFF09" class="headerlink" title="16、合并两个排序的链表（递归，简单）"></a>16、合并两个排序的链表（递归，简单）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-12"><a href="#u9898_u76EE_u63CF_u8FF0-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-11"><a href="#u89E3_u9898_u601D_u8DEF-11" class="headerlink" title="解题思路"></a>解题思路</h3><p>声明一个新链表，不断比较原来两个链表的 val 值，小的插入新链表即可。</p>
<p>递归与非递归求解，小数放在前面。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-10"><a href="#u4EE3_u7801_u5B9E_u73B0-10" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        ListNode mergeNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">            mergeNode =list1;</span><br><span class="line">            mergeNode.next=Merge(list1.next,list2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mergeNode =list2;</span><br><span class="line">            mergeNode.next=Merge(list1,list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>非递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">9999</span>);</span><br><span class="line">    ListNode tmp = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val) &#123;<span class="comment">//比较两个链表当前结点的值，小的先插入新链表</span></span><br><span class="line">            tmp.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//容错，将剩余链表补到新链表结尾，此时能保持单调不减</span></span><br><span class="line">    <span class="keyword">if</span>(list1 != <span class="keyword">null</span>) tmp.next = list1;</span><br><span class="line">    <span class="keyword">if</span>(list2 != <span class="keyword">null</span>) tmp.next = list2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.next;<span class="comment">//记得head为声明的无意义表头，head.next才是新链表的头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17_u3001_u6811_u7684_u5B50_u7ED3_u6784_uFF08_u4E00_u822C_uFF09"><a href="#17_u3001_u6811_u7684_u5B50_u7ED3_u6784_uFF08_u4E00_u822C_uFF09" class="headerlink" title="17、树的子结构（一般）"></a>17、树的子结构（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-13"><a href="#u9898_u76EE_u63CF_u8FF0-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<h3 id="u89E3_u9898_u601D_u8DEF-12"><a href="#u89E3_u9898_u601D_u8DEF-12" class="headerlink" title="解题思路"></a>解题思路</h3><p>设置终止条件进行判断，将B树与A树，A树左子树，A树右子树进行比较，递归进行即可。</p>
<ul>
<li>递归思想，如果根节点相同则递归调用IsSubtree()，如果根节点不相同，则判断<code>root1</code>的左子树和<code>roo2</code>是否相同，再判断右子树和<code>root2</code>是否相同;</li>
<li>注意节点为空的条件，<code>HasSubTree</code>中，只要有树为空就返回<code>false</code>; <code>IsSubtree</code>中，要先判断<code>root2</code>，如果<code>root2</code>为空，则说明第二棵树遍历完了，即匹配成功。</li>
</ul>
<h3 id="u5B9E_u73B0_u4EE3_u7801-1"><a href="#u5B9E_u73B0_u4EE3_u7801-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>||root2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubTree(root1,root2)|| <span class="comment">//root2与root1比较</span></span><br><span class="line">            isSubTree(root1.left,root2)||<span class="comment">//root2与root1左子树比较</span></span><br><span class="line">            isSubTree(root1.right,root2);<span class="comment">//root2与root1右比较</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubTree</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//注意！！！，先判断root2是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">            <span class="comment">//当root1.val == root2.val时，继续对root1，root2的左右子树分别递归此方法进行判断，均为true则为子结构</span></span><br><span class="line">            <span class="keyword">return</span> isSubTree(root1.left,root2.left) &amp;&amp; isSubTree(root1.right,root2.right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="18_u3001_u4E8C_u53C9_u6811_u7684_u955C_u50CF_uFF08_u7B80_u5355_uFF09"><a href="#18_u3001_u4E8C_u53C9_u6811_u7684_u955C_u50CF_uFF08_u7B80_u5355_uFF09" class="headerlink" title="18、二叉树的镜像（简单）"></a>18、二叉树的镜像（简单）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-14"><a href="#u9898_u76EE_u63CF_u8FF0-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>输入描述:</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 二叉树的镜像定义：源二叉树 </span><br><span class="line">&gt;     	    8</span><br><span class="line">&gt;     	   /  \</span><br><span class="line">&gt;     	  6   10</span><br><span class="line">&gt;     	 / \  / \</span><br><span class="line">&gt;     	5  7 9 11</span><br><span class="line">&gt;     	镜像二叉树</span><br><span class="line">&gt;     	    8</span><br><span class="line">&gt;     	   /  \</span><br><span class="line">&gt;     	  10   6</span><br><span class="line">&gt;     	 / \  / \</span><br><span class="line">&gt;     	11 9 7  5</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-13"><a href="#u89E3_u9898_u601D_u8DEF-13" class="headerlink" title="解题思路"></a>解题思路</h3><p>交换每个结点的左右子树，并对该结点的左右子结点分别进行此操作，递归进行即可</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-11"><a href="#u4EE3_u7801_u5B9E_u73B0-11" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        exchange(root);</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        TreeNode temp =root.left;</span><br><span class="line">        root.left =root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19_u3001_u987A_u65F6_u9488_u6253_u5370_u77E9_u9635_uFF08_u7B80_u5355_uFF09"><a href="#19_u3001_u987A_u65F6_u9488_u6253_u5370_u77E9_u9635_uFF08_u7B80_u5355_uFF09" class="headerlink" title="19、顺时针打印矩阵（简单）"></a>19、顺时针打印矩阵（简单）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-15"><a href="#u9898_u76EE_u63CF_u8FF0-15" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-14"><a href="#u89E3_u9898_u601D_u8DEF-14" class="headerlink" title="解题思路"></a>解题思路</h3><p>先得到矩阵的行和列数，然后依次旋转打印数据，一次旋转打印结束后，往对角分别前进和后退一个单位。要注意单行和单列的情况。</p>
<p>定义4个变量，left，right，top，bottom。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-12"><a href="#u4EE3_u7801_u5B9E_u73B0-12" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].length;</span><br><span class="line">        ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>&amp;&amp; col ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> left =<span class="number">0</span>,right=col-<span class="number">1</span>,top=<span class="number">0</span>,bottom = row-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right&amp;&amp;top&lt;=bottom)&#123;</span><br><span class="line">            <span class="comment">//上：从左到右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =left;i&lt;=right;i++)&#123;</span><br><span class="line">                res.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右：从上到下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top+<span class="number">1</span>;i&lt;=bottom;i++)&#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下：从右到左</span></span><br><span class="line">            <span class="keyword">if</span>(top!=bottom)&#123; <span class="comment">// 注意！！！</span></span><br><span class="line">                <span class="comment">//防止单行情况</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i =right-<span class="number">1</span>;i&gt;=left;i--)&#123;</span><br><span class="line">                    res.add(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左：从下到上</span></span><br><span class="line">            <span class="keyword">if</span>(left!=right)&#123;<span class="comment">// 注意！！！</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom-<span class="number">1</span>;i&gt;top;i--)&#123;</span><br><span class="line">                    res.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;right--;top++;bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="20_u3001_u5305_u542Bmin_u51FD_u6570_u7684_u6808_uFF08_u4E00_u822C_uFF09"><a href="#20_u3001_u5305_u542Bmin_u51FD_u6570_u7684_u6808_uFF08_u4E00_u822C_uFF09" class="headerlink" title="20、包含min函数的栈（一般）"></a>20、包含min函数的栈（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-16"><a href="#u9898_u76EE_u63CF_u8FF0-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-15"><a href="#u89E3_u9898_u601D_u8DEF-15" class="headerlink" title="解题思路"></a>解题思路</h3><p>用一个栈stack保存数据，用另外一个栈minStack保存依次入栈最小的数。</p>
<p>==minStack用于存储任一元素入栈时，当前栈内的最小值，与stack同步入栈出栈的，即两个栈内元素数目相同。比如，stack中依次入栈：==<br><code>5, 3, 4, 10, 2, 12, 1, 8</code><br>则minStack依次入栈：<br><code>5, 3, 3，3, 2, 2, 1, 1</code></p>
<p>每次入栈的时候，如果入栈的元素比min中的栈顶元素小或等于则入栈，否则用最小元素入栈。</p>
<h3 id="u5B9E_u73B0_u4EE3_u7801-2"><a href="#u5B9E_u73B0_u4EE3_u7801-2" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack =<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> minValue = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span>(node&lt;minValue)&#123;</span><br><span class="line">            minStack.push(node);</span><br><span class="line">            minValue = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minStack.push(minValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top =stack.peek();</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = minStack.peek();</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="21_u3001_u6808_u7684_u538B_u5165_u3001_u5F39_u51FA_u5E8F_u5217_uFF08_u4E00_u822C_uFF09"><a href="#21_u3001_u6808_u7684_u538B_u5165_u3001_u5F39_u51FA_u5E8F_u5217_uFF08_u4E00_u822C_uFF09" class="headerlink" title="21、栈的压入、弹出序列（一般）"></a>21、栈的压入、弹出序列（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-17"><a href="#u9898_u76EE_u63CF_u8FF0-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h3 id="u89E3_u9898_u601D_u8DEF-16"><a href="#u89E3_u9898_u601D_u8DEF-16" class="headerlink" title="解题思路"></a>解题思路</h3><p>==<strong>模拟堆栈操作的过程，将原数列依次压栈，把栈顶元素与所给出栈队列相比，如果相同则出栈；如果不同则继续压栈，直到原数列中所有数字压栈完毕。</strong>==</p>
<p>最后，检测栈中是否为空，若空，说明出栈队列可由原数列进行栈操作得到。否则，说明出栈队列不能由原数列进行栈操作得到。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-13"><a href="#u4EE3_u7801_u5B9E_u73B0-13" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA==<span class="keyword">null</span> || popA==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack =<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek()==popA[index])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="22_u3001_u4ECE_u4E0A_u5F80_u4E0B_u6253_u5370_u4E8C_u53C9_u6811_uFF08_u4E00_u822C_uFF0CBFS_uFF09"><a href="#22_u3001_u4ECE_u4E0A_u5F80_u4E0B_u6253_u5370_u4E8C_u53C9_u6811_uFF08_u4E00_u822C_uFF0CBFS_uFF09" class="headerlink" title="22、从上往下打印二叉树（一般，BFS）"></a>22、从上往下打印二叉树（一般，BFS）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-18"><a href="#u9898_u76EE_u63CF_u8FF0-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-17"><a href="#u89E3_u9898_u601D_u8DEF-17" class="headerlink" title="解题思路"></a>解题思路</h3><p>==就是二叉树的层次遍历，使用广度优先搜索（BFS）。==借助队列。</p>
<p>使用队列实现，边出队边输入，同时将其左右子节点压入队列。先将根节点加入到队列中，然后遍历队列中的元素，遍历过程中，访问该元素的左右节点，再将左右子节点加入到队列中来。<br>注意<code>Queue</code>创建的方式：<code>Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</code><br>用<code>add</code>将元素添加到队列中，用<code>remove</code>来移除并返回队首元素。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-14"><a href="#u4EE3_u7801_u5B9E_u73B0-14" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; queue =<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            root=queue.remove();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="23_u3001_u4E8C_u53C9_u641C_u7D22_u6811_u7684_u540E_u5E8F_u904D_u5386_u5E8F_u5217_uFF08_u4E00_u822C_uFF09"><a href="#23_u3001_u4E8C_u53C9_u641C_u7D22_u6811_u7684_u540E_u5E8F_u904D_u5386_u5E8F_u5217_uFF08_u4E00_u822C_uFF09" class="headerlink" title="23、二叉搜索树的后序遍历序列（一般）"></a>23、二叉搜索树的后序遍历序列（一般）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-19"><a href="#u9898_u76EE_u63CF_u8FF0-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-18"><a href="#u89E3_u9898_u601D_u8DEF-18" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉搜索树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树（二叉排序树）。即：</p>
<blockquote>
<p>二叉搜索树: 左子树&lt;根&lt; 右子树</p>
</blockquote>
<p>后序遍历：左 -&gt; 右 -&gt; 根。</p>
<p>因此，后序遍历最后一个数为根结点。通过根结点可把后序遍历分为两部分，前半部分为小于根结点的左子树，后半部分为大于根结点的右子树。然后根据此原理，递归对左右子树分别用此方法进行验证即可。</p>
<p>找到最后小于根节点的左结点的位置</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-15"><a href="#u4EE3_u7801_u5B9E_u73B0-15" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> judge(sequence,<span class="number">0</span>,sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span>[] sequence,<span class="keyword">int</span> start,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;=root)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> index =start;<span class="comment">//index记录最后一个小于根节点的左节点的位置</span></span><br><span class="line">        <span class="keyword">while</span>(index&lt;root&amp;&amp;sequence[index]&lt;sequence[root])&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时sequence[index]是第一个比根结点大的值</span></span><br><span class="line">        <span class="comment">//可将sequence[0]~sequence[index-1]认为是左子树，					    //	 sequence[index]~sequence[root-1]认为是右子树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =index;j&lt;root;j++)&#123;</span><br><span class="line">            <span class="comment">//若右子树中存在比根结点小的，则不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&lt;sequence[root])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时分别对根结点的左右子树进行迭代判断，全部为true则是后序遍历</span></span><br><span class="line">        <span class="keyword">return</span> (judge(sequence,start,index-<span class="number">1</span>)&amp;&amp;judge(sequence,index,root-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="24_u3001_u4E8C_u53C9_u6811_u4E2D_u548C_u4E3A_u67D0_u4E00_u503C_u7684_u8DEF_u5F84_28_u96BE_29"><a href="#24_u3001_u4E8C_u53C9_u6811_u4E2D_u548C_u4E3A_u67D0_u4E00_u503C_u7684_u8DEF_u5F84_28_u96BE_29" class="headerlink" title="24、二叉树中和为某一值的路径(难)"></a>24、二叉树中和为某一值的路径(难)</h2><h3 id="u9898_u76EE_u63CF_u8FF0-20"><a href="#u9898_u76EE_u63CF_u8FF0-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<h3 id="u89E3_u9898_u601D_u8DEF-19"><a href="#u89E3_u9898_u601D_u8DEF-19" class="headerlink" title="解题思路"></a>解题思路</h3><p>用<strong>深度优先搜索(DFS)</strong>或(前序遍历)的方式访问到某一结点时，把该结点添加到路径上，并用目标值减去该节点的值。如果该结点为叶结点并且目标值减去该节点的值刚好为0，则当前的路径符合要求，我们把加入res数组中。如果当前结点不是叶结点，则继续访问它的子结点。当前结点访问结束后，递归函数将自动回到它的父结点。</p>
<p>因此我们在函数退出之前要在路径上删除当前结点，以确保返回父结点时路径刚好是从叶结点到父结点的路径。</p>
<p><strong>注意</strong>：路径要求最后到达<strong>叶子结点</strong>。<br>==迭代过程中需把当前值在path中移除以保证路径正确，相当于回退到上一步的路径。==</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-16"><a href="#u4EE3_u7801_u5B9E_u73B0-16" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root ==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        target -=root.val;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(target ==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//已经到达叶子结点且targe正好减完</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            FindPath(root.left,target);</span><br><span class="line">            FindPath(root.right,target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//迭代过程中需把当前值在path中移除以保证路径正确，相当于回退到上一步的路径</span></span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="25_u3001_u590D_u6742_u94FE_u8868_u7684_u590D_u5236_uFF08_u96BE_uFF09"><a href="#25_u3001_u590D_u6742_u94FE_u8868_u7684_u590D_u5236_uFF08_u96BE_uFF09" class="headerlink" title="25、复杂链表的复制（难）"></a>25、复杂链表的复制（难）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-21"><a href="#u9898_u76EE_u63CF_u8FF0-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h3 id="u89E3_u9898_u601D_u8DEF-20"><a href="#u89E3_u9898_u601D_u8DEF-20" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>step1</strong>：在每个结点的后面（或者说每个结点与下一个结点中间）插入<strong>新结点</strong>。该新结点为克隆结点，这么做是为了连接random结点。</p>
<p><strong>step2</strong>：连接random结点。</p>
<p><strong>step3</strong>：拆分链表，下边为原链表，上边为clone链表。</p>
<p><img src="/2019/11/17/算法/剑指offer/2018121200474149.png" alt="img"></p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-17"><a href="#u4EE3_u7801_u5B9E_u73B0-17" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode temp = pHead;</span><br><span class="line">        <span class="comment">//step1：在每个结点的后面（或者说每个结点与下一个结点中间）插入【新结点】</span></span><br><span class="line">		<span class="comment">//该新结点为克隆结点，这么做是为了连接random结点</span></span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(temp.label);</span><br><span class="line">            <span class="comment">//插入clone节点</span></span><br><span class="line">            cloneNode.next=temp.next;</span><br><span class="line">            temp.next=cloneNode;</span><br><span class="line">            <span class="comment">//移除到原链表的下一个节点</span></span><br><span class="line">            temp = cloneNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//step2：连接random结点</span></span><br><span class="line">        temp =pHead;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode cloneNode =temp.next;</span><br><span class="line">            <span class="keyword">if</span>(temp.random!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//tmp.random是原链表的结点，tmp.random.next才是那个结点的clone结点</span></span><br><span class="line">                cloneNode.random = temp.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = cloneNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//step3：拆分链表</span></span><br><span class="line">        temp = pHead;</span><br><span class="line">        RandomListNode cloneHead =temp.next;</span><br><span class="line">        <span class="keyword">while</span>(temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode node =temp.next;</span><br><span class="line">            temp.next = node.next;</span><br><span class="line">            temp=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="26_u3001_u4E8C_u53C9_u641C_u7D22_u6811_u548C_u53CC_u5411_u94FE_u8868_uFF08_u96BE_uFF09"><a href="#26_u3001_u4E8C_u53C9_u641C_u7D22_u6811_u548C_u53CC_u5411_u94FE_u8868_uFF08_u96BE_uFF09" class="headerlink" title="26、二叉搜索树和双向链表（难）"></a>26、二叉搜索树和双向链表（难）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-22"><a href="#u9898_u76EE_u63CF_u8FF0-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-21"><a href="#u89E3_u9898_u601D_u8DEF-21" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于二叉搜索树<strong>左子结点 &lt; 根结点 &lt; 右子结点</strong>的性质，题目实质上是<strong>二叉搜索树</strong>的<strong>中序遍历</strong>，改结点的指针。left代表双向链表的prev指针，right代表next指针。</p>
<p>每次遍历节点的左孩子、右孩子，把左孩子指向转换链表的尾节点，并把末尾指针的右孩子指向自己。右孩子指向节点的右孩子。如果没有右孩子就返回。这一过程可以用递归实现。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-18"><a href="#u4EE3_u7801_u5B9E_u73B0-18" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>; <span class="comment">//记录上一个节点</span></span><br><span class="line">    TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        inOrder(pRootOfTree);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//实质上是中序遍历，改结点的指针。left代表双向链表的pre指针，right代表next</span></span><br><span class="line">	    <span class="comment">//左</span></span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        <span class="comment">//根</span></span><br><span class="line">	    <span class="comment">//改指针的指向（只需与上一个结点相连即可）</span></span><br><span class="line">        node.left= pre;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pre.right=node;<span class="comment">//如果上一个不为null，连此时这个</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;<span class="comment">//将pre移向此时这个结点，为下一次迭代做准备</span></span><br><span class="line">        <span class="keyword">if</span>(head ==<span class="keyword">null</span>) head =node; <span class="comment">//只在第一次找到最小结点时作为头结点</span></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="27_u3001_u5B57_u7B26_u4E32_u7684_u6392_u5217_uFF08_u96BE_uFF0C_u770B_uFF09"><a href="#27_u3001_u5B57_u7B26_u4E32_u7684_u6392_u5217_uFF08_u96BE_uFF0C_u770B_uFF09" class="headerlink" title="27、字符串的排列（难，看）"></a>27、字符串的排列（难，看）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-23"><a href="#u9898_u76EE_u63CF_u8FF0-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串,按<strong>字典序</strong>打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<blockquote>
<p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-22"><a href="#u89E3_u9898_u601D_u8DEF-22" class="headerlink" title="解题思路"></a>解题思路</h3><p>（1） 把字符串分为两部分，一部分是字符串的第一个字符，另一部分是第一个字符以后的所有字符。<br>（2） 求第一个字符后面部分的字符串的全排列<br>（3） 拿第一个字符和它后面的字符逐个交换</p>
<p><img src="/2019/11/17/算法/剑指offer/20190719192858379.png" alt="在这里插入图片描述"></p>
<p><strong>———————————分割线————————————–</strong></p>
<h2 id="28_u3001_u6570_u7EC4_u4E2D_u51FA_u73B0_u6B21_u6570_u8D85_u8FC7_u4E00_u534A_u7684_u6570_u5B57"><a href="#28_u3001_u6570_u7EC4_u4E2D_u51FA_u73B0_u6B21_u6570_u8D85_u8FC7_u4E00_u534A_u7684_u6570_u5B57" class="headerlink" title="28、数组中出现次数超过一半的数字"></a>28、数组中出现次数超过一半的数字</h2><h3 id="u9898_u76EE_u63CF_u8FF0-24"><a href="#u9898_u76EE_u63CF_u8FF0-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-23"><a href="#u89E3_u9898_u601D_u8DEF-23" class="headerlink" title="解题思路"></a>解题思路</h3><p>在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-19"><a href="#u4EE3_u7801_u5B9E_u73B0-19" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==num)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count ==<span class="number">0</span>)&#123;</span><br><span class="line">                num = array[i];</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val:array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val ==num)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count&gt;array.length/<span class="number">2</span>?num:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="29_u3001_u6700_u5C0F_u7684k_u4E2A_u6570_uFF08_u4E00_u822C_uFF0C_u5806_uFF09"><a href="#29_u3001_u6700_u5C0F_u7684k_u4E2A_u6570_uFF08_u4E00_u822C_uFF0C_u5806_uFF09" class="headerlink" title="29、最小的k个数（一般，堆）"></a>29、最小的k个数（一般，堆）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-25"><a href="#u9898_u76EE_u63CF_u8FF0-25" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-24"><a href="#u89E3_u9898_u601D_u8DEF-24" class="headerlink" title="解题思路"></a>解题思路</h3><p>用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，新数入堆。</p>
<p><a href="https://www.nowcoder.com/questionTerminal/6a296eb82cf844ca8539b57c23e6e9bf?f=discussion" target="_blank" rel="noopener">参考牛客</a></p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-20"><a href="#u4EE3_u7801_u5B9E_u73B0-20" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = input.length;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;length||k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1,o2)-&gt;o2-o1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:input)&#123;</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size()&gt;k)</span><br><span class="line">                maxHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:maxHeap)&#123;</span><br><span class="line">            result.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="30_u3001_u8FDE_u7EED_u5B50_u6570_u7EC4_u7684_u6700_u5927_u548C_28_u7B80_u5355_uFF0C_u52A8_u6001_u89C4_u5212_29"><a href="#30_u3001_u8FDE_u7EED_u5B50_u6570_u7EC4_u7684_u6700_u5927_u548C_28_u7B80_u5355_uFF0C_u52A8_u6001_u89C4_u5212_29" class="headerlink" title="30、连续子数组的最大和(简单，动态规划)"></a>30、连续子数组的最大和(简单，动态规划)</h2><h3 id="u9898_u76EE_u63CF_u8FF0-26"><a href="#u9898_u76EE_u63CF_u8FF0-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整型数组，数组里有正数和负数，数组中一个或者多个连续的数字组成一个子数组，求所有子数组的最大值，要求时间复杂度为O(N)</p>
<h3 id="u89E3_u9898_u601D_u8DEF-25"><a href="#u89E3_u9898_u601D_u8DEF-25" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-21"><a href="#u4EE3_u7801_u5B9E_u73B0-21" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划，主要是找到状态转移方程</span></span><br><span class="line">        <span class="comment">//设sum(j)是从array[0]到array[j]最大和</span></span><br><span class="line">        <span class="comment">//sum(j) = max(array[j], sum[j-1]+array[j])</span></span><br><span class="line">        <span class="keyword">if</span>(array.length ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result =Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            sum = Math.max(array[i],sum+array[i]);</span><br><span class="line">            result = Math.max(result,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="31_u3001_u6574_u6570_u4E2D1_u51FA_u73B0_u7684_u6B21_u6570_uFF08_u4ECE1_u5230n_u6574_u6570_u4E2D1_u51FA_u73B0_u7684_u6B21_u6570_uFF09"><a href="#31_u3001_u6574_u6570_u4E2D1_u51FA_u73B0_u7684_u6B21_u6570_uFF08_u4ECE1_u5230n_u6574_u6570_u4E2D1_u51FA_u73B0_u7684_u6B21_u6570_uFF09" class="headerlink" title="31、整数中1出现的次数（从1到n整数中1出现的次数）"></a>31、整数中1出现的次数（从1到n整数中1出现的次数）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-27"><a href="#u9898_u76EE_u63CF_u8FF0-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1到n中1出现的次数）。</p>
<blockquote>
<p>例如n=13的整数中1出现的次数，1~13中包含1的数字有1、10、11、12、13因此共出现6次</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-26"><a href="#u89E3_u9898_u601D_u8DEF-26" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>——————————–分隔符—————————————</strong></p>
<h2 id="32_u3001_u628A_u6570_u7EC4_u6392_u6210_u6700_u5C0F_u7684_u6570"><a href="#32_u3001_u628A_u6570_u7EC4_u6392_u6210_u6700_u5C0F_u7684_u6570" class="headerlink" title="32、把数组排成最小的数"></a>32、把数组排成最小的数</h2><h3 id="u9898_u76EE_u63CF_u8FF0-28"><a href="#u9898_u76EE_u63CF_u8FF0-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-27"><a href="#u89E3_u9898_u601D_u8DEF-27" class="headerlink" title="解题思路"></a>解题思路</h3><p>可以看做是排序问题，不同点在于此题是<strong>比较数字转换成字符串后相加的大小</strong>。</p>
<p>例如两个数字转换的字符串S1和S2，应该比较 <strong>S1+S2</strong> 和 <strong>S2+S1</strong> 的大小，如果 S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。</p>
<h3 id="u4EE3_u7801_u601D_u8DEF"><a href="#u4EE3_u7801_u601D_u8DEF" class="headerlink" title="代码思路"></a>代码思路</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        String[] nums = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i]=String.valueOf(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums,(s1,s2)-&gt;(s1+s2).compareTo(s2+s1));</span><br><span class="line">        String result =<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(String str:nums)&#123;</span><br><span class="line">            result+=str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="33_u3001_u4E11_u6570"><a href="#33_u3001_u4E11_u6570" class="headerlink" title="33、丑数"></a>33、丑数</h2><h3 id="u9898_u76EE_u63CF_u8FF0-29"><a href="#u9898_u76EE_u63CF_u8FF0-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-28"><a href="#u89E3_u9898_u601D_u8DEF-28" class="headerlink" title="解题思路"></a>解题思路</h3><p>此题需要思维灵活。由题意，只需不断从前面已知的丑数中<strong>选取合适的丑数</strong>分别乘2、3、5，选取<strong>最小</strong>的丑数加入数组即可。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-22"><a href="#u4EE3_u7801_u5B9E_u73B0-22" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">6</span>) <span class="comment">//1-6即为前6个丑数</span></span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        <span class="keyword">int</span> uglys[]=<span class="keyword">new</span> <span class="keyword">int</span>[index];<span class="comment">//存前N个丑数</span></span><br><span class="line">        uglys[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//初始化第一个值为1</span></span><br><span class="line">        <span class="keyword">int</span> i2=<span class="number">0</span>,i3=<span class="number">0</span>,i5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="comment">//找出下一个小的丑数,此步重要需理解，分别用2,3,5在丑数数组里对应的上一个丑数乘2,3,5找出最小的丑数</span></span><br><span class="line">            <span class="keyword">int</span> next2 = uglys[i2]*<span class="number">2</span>,next3=uglys[i3]*<span class="number">3</span>,next5=uglys[i5]*<span class="number">5</span>;</span><br><span class="line">            uglys[i]=Math.min(next2,Math.min(next3,next5));</span><br><span class="line">            <span class="comment">//将2,3,5对应的上一个丑数后移</span></span><br><span class="line">            <span class="keyword">if</span>(uglys[i]==next2)</span><br><span class="line">                i2++;</span><br><span class="line">            <span class="keyword">if</span>(uglys[i]==next3)</span><br><span class="line">                i3++;</span><br><span class="line">            <span class="keyword">if</span>(uglys[i]==next5)</span><br><span class="line">                i5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uglys[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="34_u3001_u7B2C_u4E00_u4E2A_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u5B57_u7B26_28_u6B67_u4E49_29"><a href="#34_u3001_u7B2C_u4E00_u4E2A_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u5B57_u7B26_28_u6B67_u4E49_29" class="headerlink" title="34、第一个只出现一次的字符(歧义)"></a>34、第一个只出现一次的字符(歧义)</h2><h3 id="u9898_u76EE_u63CF_u8FF0-30"><a href="#u9898_u76EE_u63CF_u8FF0-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符，并返回它的位置，如果没有则返回 -1（需要区分大小写）。</p>
<blockquote>
<p>Input: abacc<br>Output: b</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-29"><a href="#u89E3_u9898_u601D_u8DEF-29" class="headerlink" title="解题思路"></a>解题思路</h3><p>char类型一般为一个字节，范围在0 ~ 255。因此定义一个整形<strong>计数数组</strong>int[256]，对每个char出现次数进行计数即可。</p>
<p>计数后要按照<strong>字符串中的字符顺序</strong>查找第一个计数次数为1的字符。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-23"><a href="#u4EE3_u7801_u5B9E_u73B0-23" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            array[str.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[str.charAt(i)]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="35_u3001_u6570_u7EC4_u4E2D_u7684_u9006_u5E8F_u5BF9_uFF08_u5F52_u5E76_2C_u96BE_uFF0C_u770B_uFF09"><a href="#35_u3001_u6570_u7EC4_u4E2D_u7684_u9006_u5E8F_u5BF9_uFF08_u5F52_u5E76_2C_u96BE_uFF0C_u770B_uFF09" class="headerlink" title="35、数组中的逆序对（归并,难，看）"></a>35、数组中的逆序对（归并,难，看）</h2><h3 id="u9898_u76EE_u63CF_u8FF0-31"><a href="#u9898_u76EE_u63CF_u8FF0-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。</p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题目保证输入的数组中没有的相同的数字</span><br><span class="line">数据范围：	</span><br><span class="line">		对于%50的数据,size&lt;=10^4</span><br><span class="line">         对于%75的数据,size&lt;=10^5	</span><br><span class="line">         对于%100的数据,size&lt;=2*10^5</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3,4,5,6,7,0</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h3 id="u89E3_u9898_u601D_u8DEF-30"><a href="#u89E3_u9898_u601D_u8DEF-30" class="headerlink" title="解题思路"></a>解题思路</h3><p>分治思想，先分后治。先不断将数组一分为二，并对这分开的两部分进行相同操作；然后一边合并相邻的子数组，一边统计逆序对的数目。（实质就是归并排序的思路）</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-24"><a href="#u4EE3_u7801_u5B9E_u73B0-24" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tmp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        tmp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        mergeSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(cnt%<span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right-left&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array,left,mid);</span><br><span class="line">        mergeSort(array,mid+<span class="number">1</span>,right);</span><br><span class="line">        merge(array,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=left,j=mid+<span class="number">1</span>,k=left;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid||j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;mid)&#123;</span><br><span class="line">                tmp[k]=array[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;right)&#123;</span><br><span class="line">                tmp[k]=array[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[i]&lt;array[j])&#123;</span><br><span class="line">                tmp[k]=array[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[k]=array[j];</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">this</span>.cnt+=mid-i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(k=left;k&lt;=right;k++)&#123;</span><br><span class="line">            array[k]=tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="36_u3001_u4E24_u4E2A_u94FE_u8868_u7684_u7B2C_u4E00_u4E2A_u516C_u5171_u7ED3_u70B9"><a href="#36_u3001_u4E24_u4E2A_u94FE_u8868_u7684_u7B2C_u4E00_u4E2A_u516C_u5171_u7ED3_u70B9" class="headerlink" title="36、两个链表的第一个公共结点"></a>36、两个链表的第一个公共结点</h2><h3 id="u9898_u76EE_u63CF_u8FF0-32"><a href="#u9898_u76EE_u63CF_u8FF0-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个链表，找出它们的第一个公共结点。</p>
<h3 id="u89E3_u9898_u601D_u8DEF-31"><a href="#u89E3_u9898_u601D_u8DEF-31" class="headerlink" title="解题思路"></a>解题思路</h3><p><img src="/2019/11/17/算法/剑指offer/20181212233050681.png" alt="img"></p>
<p>如图，链表1长度为 a+c，链表2长度为 b+c。声明两个指针node1和node2分别指向两个链表表头，同步向后移动。</p>
<p>node1走过 a+c 后指空，此时让它指向链表2的表头并继续向后走；同理node2走过 b+c 后指向链表1表头。</p>
<p>由于 a+c+b = b+c+a ，此时node1和node2刚好相遇，且相遇在两个链表的第一个公共结点。由此得解。</p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-25"><a href="#u4EE3_u7801_u5B9E_u73B0-25" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode node1 = pHead1;</span><br><span class="line">        ListNode node2 = pHead2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(node1!=node2)&#123;  <span class="comment">//终止条件：找到相同的结点</span></span><br><span class="line">            <span class="keyword">if</span>(node1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                node1 = pHead2;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                node2 =pHead1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node2=node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="37_u3001_u6570_u5B57_u5728_u6392_u5E8F_u6570_u7EC4_u4E2D_u51FA_u73B0_u7684_u6B21_u6570_28_u4E8C_u5206_29"><a href="#37_u3001_u6570_u5B57_u5728_u6392_u5E8F_u6570_u7EC4_u4E2D_u51FA_u73B0_u7684_u6B21_u6570_28_u4E8C_u5206_29" class="headerlink" title="37、数字在排序数组中出现的次数(二分)"></a>37、数字在排序数组中出现的次数(二分)</h2><h3 id="u9898_u76EE_u63CF_u8FF0-33"><a href="#u9898_u76EE_u63CF_u8FF0-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>统计一个数字在排序数组中出现的次数</p>
<blockquote>
<p>Input:<br>nums = 1, 2, 3, 3, 3, 3, 4, 6<br>K = 3</p>
<p>Output:<br>4</p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-32"><a href="#u89E3_u9898_u601D_u8DEF-32" class="headerlink" title="解题思路"></a>解题思路</h3><p>二分查找，可以参考<a href="E:\Notes\算法\02-LeetCode\算法细节\二分查找细节.md" target="_blank" rel="noopener">二分查找细节</a></p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-26"><a href="#u4EE3_u7801_u5B9E_u73B0-26" class="headerlink" title="代码实现"></a>代码实现</h3><p>照着模版写就完事了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = getFirstK(array,k);</span><br><span class="line">        <span class="keyword">int</span> last = getLastK(array,k);</span><br><span class="line">        <span class="keyword">if</span>(first==-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(last ==-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> last-first+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//找最左边的</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid =left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==k)</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;k)</span><br><span class="line">                left =mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[left]==k?left:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span></span>&#123;  <span class="comment">//找最右边的</span></span><br><span class="line">        <span class="keyword">int</span> left =<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==k)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;k)</span><br><span class="line">                left=mid+<span class="number">1</span>;                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right =mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[right]==k?right:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="38_u3001_u4E8C_u53C9_u6811_u7684_u6DF1_u5EA6"><a href="#38_u3001_u4E8C_u53C9_u6811_u7684_u6DF1_u5EA6" class="headerlink" title="38、二叉树的深度"></a>38、二叉树的深度</h2><h3 id="u9898_u76EE_u63CF_u8FF0-34"><a href="#u9898_u76EE_u63CF_u8FF0-34" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 </p>
<h3 id="u89E3_u9898_u601D_u8DEF-33"><a href="#u89E3_u9898_u601D_u8DEF-33" class="headerlink" title="解题思路"></a>解题思路</h3><p> 分别对左右子树递归计算深度，取深度更大的一个。 </p>
<p><img src="/2019/11/17/算法/剑指offer/124213_1560686577137_ba355101-4a93-4c71-94fb-1da83639727b.jpg" alt="img"></p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-27"><a href="#u4EE3_u7801_u5B9E_u73B0-27" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> root==<span class="keyword">null</span>?<span class="number">0</span>:<span class="number">1</span>+Math.max(TreeDepth(root.left),TreeDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="39_u3001_u5E73_u8861_u4E8C_u53C9_u6811"><a href="#39_u3001_u5E73_u8861_u4E8C_u53C9_u6811" class="headerlink" title="39、平衡二叉树"></a>39、平衡二叉树</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树</p>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>平衡二叉树的平衡因子的绝对值&lt;= 1. </p>
<p><img src="/2019/11/17/算法/剑指offer/124213_1560686577152_af1d1166-63af-47b6-9aa3-2bf2bd37bd03.jpg" alt="img"></p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val =<span class="number">0</span></span><br><span class="line">    TreeNode left ==<span class="keyword">null</span>;</span><br><span class="line">    TreeNode right ==<span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val =val;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//abs：绝对值</span></span><br><span class="line">        <span class="keyword">boolean</span> condition = Math.abs(treePath(root.left)-treePath(root.right)) &lt;=<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">return</span> condition &amp;&amp; IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treePath</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="keyword">null</span>?<span class="number">0</span>:<span class="number">1</span>+Math.max(treePath(root.left),treePath(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="40_u3001_u6570_u7EC4_u4E2D_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u6570_u5B57"><a href="#40_u3001_u6570_u7EC4_u4E2D_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u6570_u5B57" class="headerlink" title="40、数组中只出现一次的数字"></a>40、数组中只出现一次的数字</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-1"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-1" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>一个整形数组里除了两个数字之外，其他的数字都出现了两次。请写出程序找出这两个只出现一次的数字</p>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-1"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-1" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p><strong>重点</strong>：注意题意，两个数只出现<strong>一次</strong>，其他数都出现<strong>偶数次</strong>。</p>
<p>方法一：<strong>HashSet</strong>。不包含则加入，包含则移除。最终出现偶数次的数一定都会被移除，仅留只出现了一次的数。</p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-1"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><p>法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set =<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(num))&#123;</span><br><span class="line">                set.remove(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;Integer&gt; it = set.iterator();</span><br><span class="line">        num1[<span class="number">0</span>] = it.next();</span><br><span class="line">        num2[<span class="number">0</span>] = it.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="41_u3001_u548C_u4E3AS_u7684_u4E24_u4E2A_u6570_u5B57"><a href="#41_u3001_u548C_u4E3AS_u7684_u4E24_u4E2A_u6570_u5B57" class="headerlink" title="41、和为S的两个数字"></a>41、和为S的两个数字</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-2"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-2" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
</blockquote>
<blockquote>
<p>输出描述：输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序  </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-2"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-2" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>夹逼思想，使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<p>如果两个指针指向元素的和 sum == target，那么得到要求的结果；<br>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；<br>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-2"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-2" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = array[i]+array[j];</span><br><span class="line">            <span class="keyword">if</span>(cur == sum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(array[i],array[j]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur&lt;sum)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="42_u3001_u548C_u4E3AS_u7684_u8FDE_u7EED_u6B63_u6570_u5E8F_u5217_uFF08_u770B_uFF0C_u96BE_uFF09"><a href="#42_u3001_u548C_u4E3AS_u7684_u8FDE_u7EED_u6B63_u6570_u5E8F_u5217_uFF08_u770B_uFF0C_u96BE_uFF09" class="headerlink" title="42、和为S的连续正数序列（看，难）"></a>42、和为S的连续正数序列（看，难）</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-3"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-3" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>输出所有和为 S 的连续正数序列。 </p>
<p>例如和为 100 的连续序列有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; [9, 10, 11, 12, 13, 14, 15, 16]</span><br><span class="line">&gt; [18, 19, 20, 21, 22]。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-3"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-3" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p> 夹逼思想，定义正数序列的左边界small和右边界big，求small到big的和。和比所求小则big后移，比所求大则small后移。 </p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-3"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-3" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=<span class="number">1</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> small =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> big=<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(small&lt;(sum+<span class="number">1</span>)/<span class="number">2</span>)&#123; <span class="comment">//要求最少两个数，所以small最大为（sum+1)/2</span></span><br><span class="line">            <span class="keyword">int</span> curSum = <span class="number">0</span>;<span class="comment">//求small到big的和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=small;i&lt;=big;i++)&#123;</span><br><span class="line">                curSum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//夹逼思想，小则big后移，大则small后移</span></span><br><span class="line">            <span class="keyword">if</span>(curSum&lt;sum)&#123;</span><br><span class="line">                big++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum&gt;sum)&#123;</span><br><span class="line">                small++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//相等，即为所求</span></span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=small;i&lt;=big;i++)&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">                small++;  <span class="comment">//往下继续找满足和为sum的答案</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="43_u3001_u5DE6_u65CB_u8F6C_u5B57_u7B26_u4E32"><a href="#43_u3001_u5DE6_u65CB_u8F6C_u5B57_u7B26_u4E32" class="headerlink" title="43、左旋转字符串"></a>43、左旋转字符串</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-4"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-4" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-4"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-4" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p> 先将整个字符串翻转，然后将每个单词翻转。 </p>
<p>分三步走。（交换步骤顺序也可）</p>
<p>step1：先将左边3个字符串进行翻转：[abc]XYZdef –&gt; [cba]XYZdef</p>
<p>step2：再将右边剩余字符串进行翻转：cba[XYZdef] –&gt; cba[fedZYX]</p>
<p>step3：最后将整个字符串进行翻转： cbafedZYX –&gt; XYZdefabc</p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-4"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-4" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] chars =str.toCharArray();</span><br><span class="line">        <span class="comment">//step1:先将左边3个字符串进行翻转：[abc]XYZdef --&gt; [cba]XYZdef</span></span><br><span class="line">        reverse(chars,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//step2:再将右边剩余字符串进行翻转：cba[XYZdef] --&gt; cba[fedZYX]</span></span><br><span class="line">        reverse(chars,n,chars.length-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//step3:最后将整个字符串进行翻转：cbafedZYX --&gt; XYZdefabc</span></span><br><span class="line">        reverse(chars,<span class="number">0</span>,chars.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[start];</span><br><span class="line">            chars[start] = chars[end];</span><br><span class="line">            chars[end]=temp;</span><br><span class="line">            </span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="44_u3001_u7FFB_u8F6C_u5355_u8BCD_u987A_u5E8F_u5217"><a href="#44_u3001_u7FFB_u8F6C_u5355_u8BCD_u987A_u5E8F_u5217" class="headerlink" title="44、翻转单词顺序列"></a>44、翻转单词顺序列</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-5"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-5" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;I am a student.&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;student. a am I&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-5"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-5" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>与上一题类似， 先翻转每个单词的顺序，再翻转整个句子的顺序。 </p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-5"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-5" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> length =chars.length;</span><br><span class="line">        <span class="keyword">int</span> startIndex=<span class="number">0</span>;<span class="comment">//单词开始标记</span></span><br><span class="line">        <span class="keyword">int</span> endIndex=<span class="number">0</span>;<span class="comment">//单词结束标记</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//（注意）与上一题不同：翻转每个单词的字母顺序</span></span><br><span class="line">        <span class="keyword">while</span>(endIndex &lt;= length)&#123;</span><br><span class="line">            <span class="comment">//遇到空格或到句末，翻转单词</span></span><br><span class="line">            <span class="keyword">if</span>(endIndex == length||chars[endIndex]==<span class="string">' '</span>)&#123;</span><br><span class="line">                reversed(chars,startIndex,endIndex-<span class="number">1</span>);</span><br><span class="line">                startIndex = endIndex+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            endIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        reversed(chars,<span class="number">0</span>,length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reversed</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[start];</span><br><span class="line">            chars[start] = chars[end];</span><br><span class="line">            chars[end]= temp;</span><br><span class="line">            </span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="45_u3001_u6251_u514B_u724C_u987A_u5B50"><a href="#45_u3001_u6251_u514B_u724C_u987A_u5B50" class="headerlink" title="45、扑克牌顺子"></a>45、扑克牌顺子</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-6"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-6" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张_)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-6"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-6" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p> 先对数组排序，计算大小王（癞子）数量。然后计算剩下的数两两的差值减1即为需要用癞子替代的张数。题那么长都是废话，别想太多正常找就行。 </p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-6"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-6" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span>||numbers.length&lt;<span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="keyword">int</span> sum0=<span class="number">0</span>;<span class="comment">//大小王数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                sum0++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =sum0;i&lt;numbers.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//有相等的牌不可能成为顺子</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i+<span class="number">1</span>]==numbers[i]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//两个数之间差了几张牌</span></span><br><span class="line">            <span class="keyword">int</span> interval= numbers[i+<span class="number">1</span>]-numbers[i]-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//相差太大，大小王不够</span></span><br><span class="line">            <span class="keyword">if</span>(interval&gt;sum0) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            sum0-=interval;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="46_u3001_u5B69_u5B50_u4EEC_u7684_u6E38_u620F_uFF08_u5706_u5708_u4E2D_u6700_u540E_u5269_u4E0B_u7684_u6570_uFF09"><a href="#46_u3001_u5B69_u5B50_u4EEC_u7684_u6E38_u620F_uFF08_u5706_u5708_u4E2D_u6700_u540E_u5269_u4E0B_u7684_u6570_uFF09" class="headerlink" title="46、孩子们的游戏（圆圈中最后剩下的数）"></a>46、孩子们的游戏（圆圈中最后剩下的数）</h3><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-7"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-7" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>如果没有小朋友，请返回-1</p>
</blockquote>
<p>简化版本：</p>
<blockquote>
<p>一个环，每次删除第m个数字，求最后一个数字，如0，1，2，3，4这5个数字，从0开始每次删除第3个数字，则依次删除2，0，4，1，最后一个数字是3 </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-7"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-7" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>法一： 约瑟夫经典解法，O(N)，空间复杂度O(1) </p>
<p><strong>约瑟夫环</strong>，公式：</p>
<blockquote>
<p>n = 1： f(n, m) = 0<br>n &gt; 1： f(n, m) = [f(n - 1, m) + m] % n </p>
</blockquote>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-7"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-7" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><p>法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            f=(f+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="46_u3001_u6C421+2+3+_u2026+n"><a href="#46_u3001_u6C421+2+3+_u2026+n" class="headerlink" title="46、求1+2+3+…+n"></a>46、求1+2+3+…+n</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-8"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-8" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p> 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-8"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-8" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p> 递归相加。此题关键在于如何跳出递归，基本方向是采用逻辑与或的方式来计算，与的时候通过n&gt;0来短路，这样在n=0的时候不需要计算递归的值，或的时候通过n==0来短路，在n=0的时候可以短路逻辑或运算。 </p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-8"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-8" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = n;</span><br><span class="line">    <span class="comment">//boolean b = (n &gt; 0) &amp;&amp; (sum += Sum_Solution(n - 1)) &gt; 0;</span></span><br><span class="line">    <span class="keyword">boolean</span> b = (n == <span class="number">0</span>) || (sum += Sum_Solution(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="47_u3001_u4E0D_u7528_u52A0_u51CF_u4E58_u9664_u505A_u52A0_u6CD5"><a href="#47_u3001_u4E0D_u7528_u52A0_u51CF_u4E58_u9664_u505A_u52A0_u6CD5" class="headerlink" title="47、不用加减乘除做加法"></a>47、不用加减乘除做加法</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-9"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-9" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p> 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 </p>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-9"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-9" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p> 位运算。a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。 </p>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215?answerType=1&amp;f=discussion来源：牛客网" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215?answerType=1&amp;f=discussion来源：牛客网</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先看十进制是如何做的： 5+7=12，三步走</span><br><span class="line">第一步：相加各位的值，不算进位，得到2。</span><br><span class="line">第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</span><br><span class="line">第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</span><br><span class="line"></span><br><span class="line">同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，</span><br><span class="line">得到010，二进制每位相加就相当于各位做异或操作，101^111。</span><br><span class="line">第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</span><br><span class="line">第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。</span><br><span class="line">继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果</span><br></pre></td></tr></table></figure>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-9"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-9" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = num1 ^ num2;</span><br><span class="line">            num2 = (num1 &amp; num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1 =tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="48_u3001_u628A_u5B57_u7B26_u4E32_u8F6C_u6362_u6210_u6574_u6570_28_u51FA_u9519_29"><a href="#48_u3001_u628A_u5B57_u7B26_u4E32_u8F6C_u6362_u6210_u6574_u6570_28_u51FA_u9519_29" class="headerlink" title="48、把字符串转换成整数(出错)"></a>48、把字符串转换成整数(出错)</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-10"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-10" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p> 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 </p>
</blockquote>
<blockquote>
<p>输入描述:<br>输入一个字符串，包括数字字母符号，可以为空<br>输出描述:<br>如果是合法的数值表达则返回该数字，否则返回0 </p>
</blockquote>
<p>示例</p>
<blockquote>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; +2147483647</span><br><span class="line">&gt;     1a33</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 2147483647</span><br><span class="line">&gt;     0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-10"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-10" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>正常转换即可</p>
<p> 此题主要是注意细节：<br>1、功能测试：输入有+-号情况，区分正负数和0<br>2、特殊输入：空字符串情况，输入非数字字符串情况，如a12<br>3、边界值：最大正整数和最小负整数溢出情况 </p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-10"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-10" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span> isNegative = chars[<span class="number">0</span>] ==<span class="string">'-'</span>;<span class="comment">//判断是否有负号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;(chars[i]==<span class="string">'+'</span>||chars[i]==<span class="string">'-'</span>)) <span class="keyword">continue</span>;<span class="comment">//跳过正负号</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(chars[i]&lt;<span class="string">'0'</span>||chars[i]&gt;<span class="string">'9'</span>) <span class="comment">//非法输入</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            result = result*<span class="number">10</span>+(chars[i]-<span class="string">'0'</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative?-result:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="49_u3001_u6570_u7EC4_u4E2D_u91CD_u590D_u7684_u6570_u5B57"><a href="#49_u3001_u6570_u7EC4_u4E2D_u91CD_u590D_u7684_u6570_u5B57" class="headerlink" title="49、数组中重复的数字"></a>49、数组中重复的数字</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-11"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-11" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-11"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-11" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p><img src="/2019/11/17/算法/剑指offer/20160525171645123" alt="这里写图片描述"></p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-11"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-11" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers ==<span class="keyword">null</span>||length&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(numbers[i]!=i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[i]==numbers[numbers[i]])&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>]=numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    swap(numbers,i,numbers[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="50_u3001_u6784_u5EFA_u4E58_u79EF_u6570_u7EC4"><a href="#50_u3001_u6784_u5EFA_u4E58_u79EF_u6570_u7EC4" class="headerlink" title="50、构建乘积数组"></a>50、构建乘积数组</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-12"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-12" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0] <em> A[1] </em> … <em> A[i-1] </em> A[i+1] <em> … </em> A[n-1]。不能使用除法。 </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-12"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-12" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p><img src="/2019/11/17/算法/剑指offer/20181215213441301.png" alt="img"></p>
<p>分三步走。如图，构建左下部分的前向乘积数组和右上部分的后向乘积数组。</p>
<p>step1：构建前向乘积数组C[i] = A[0] <em> A[1] </em> … <em> A[i-1]，即C[i] = C[i-1] </em> A[i-1]</p>
<p>step2：构建后向乘积数组D[i] = A[n-1] <em> A[n-2] </em> …A[n-i+1]，即D[i] = D[i+1] * A[i+1]</p>
<p>step3：B[i] = C[i] * D[i]</p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-12"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-12" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> len=A.length;</span><br><span class="line">        <span class="keyword">int</span>[] B=<span class="keyword">new</span> <span class="keyword">int</span>[len];<span class="comment">//乘积数组</span></span><br><span class="line">        <span class="keyword">int</span>[] C=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] D=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构建前向乘积数组C[i]=A[0]*A[1]*...*A[i-1],即C[i]=C[i-1]*A[i-1];</span></span><br><span class="line">        C[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            C[i]=C[i-<span class="number">1</span>]*A[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构建后向乘积数组D[i]=A[n-1]*A[n-2]*...*A[n-i+1],即D[i]=D[i+1]*A[i+1]</span></span><br><span class="line">        D[len-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            D[i]=D[i+<span class="number">1</span>]*A[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//B[i]=C[i]*D[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            B[i]=C[i]*D[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="51_u3001_u6B63_u5219_u8868_u8FBE_u5F0F_u5339_u914D_uFF08_u6CA1_u505A_uFF09"><a href="#51_u3001_u6B63_u5219_u8868_u8FBE_u5F0F_u5339_u914D_uFF08_u6CA1_u505A_uFF09" class="headerlink" title="51、正则表达式匹配（没做）"></a>51、正则表达式匹配（没做）</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-13"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-13" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配 </p>
</blockquote>
<h2 id="52_u3001_u8868_u793A_u6570_u503C_u7684_u5B57_u7B26_u4E32_uFF08_u6CA1_u505A_uFF09"><a href="#52_u3001_u8868_u793A_u6570_u503C_u7684_u5B57_u7B26_u4E32_uFF08_u6CA1_u505A_uFF09" class="headerlink" title="52、表示数值的字符串（没做）"></a>52、表示数值的字符串（没做）</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-14"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-14" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><h2 id="53_u3001_u5B57_u7B26_u6D41_u4E2D_u7B2C_u4E00_u4E2A_u4E0D_u91CD_u590D_u7684_u5B57_u7B26"><a href="#53_u3001_u5B57_u7B26_u6D41_u4E2D_u7B2C_u4E00_u4E2A_u4E0D_u91CD_u590D_u7684_u5B57_u7B26" class="headerlink" title="53、字符流中第一个不重复的字符"></a>53、字符流中第一个不重复的字符</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-15"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-15" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p> 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br>（如果当前字符流没有存在出现一次的字符，返回#字符。） </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-13"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-13" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p> 原理同T34，定义下标计数数组，插入字符时计数，同时记录字符串。输出时按照字符串中<strong>字符顺序</strong>找到第一个计数为1的即可。 </p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-13"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-13" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        str+=ch;</span><br><span class="line">        count[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(count[str.charAt(i)]==<span class="number">1</span>) </span><br><span class="line">               <span class="keyword">return</span> str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="54_u3001_u94FE_u8868_u4E2D_u73AF_u7684_u5165_u53E3_u7ED3_u70B9"><a href="#54_u3001_u94FE_u8868_u4E2D_u73AF_u7684_u5165_u53E3_u7ED3_u70B9" class="headerlink" title="54、链表中环的入口结点"></a>54、链表中环的入口结点</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-16"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-16" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p> 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 </p>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-14"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-14" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>定义快慢两个指针，相遇后（环中相汇点）将快指针指向pHead 然后一起走，每次往后挪一位，相遇的节点即为所求。</p>
<p>详细分析：相遇即p1\==p2时，p2所经过节点数为2x,p1所经过节点数为x,设环中有n个节点,p2比p1多走一圈有2x=n+x; n=x;可以看出p1实际走了一个环的步数，再让p2指向链表头部，p1位置不变，p1,p2每次走一步直到p1==p2; 此时p1指向环的入口。</p>
<h3 id="3_u3001_u89E3_u9898_u601D_u8DEF"><a href="#3_u3001_u89E3_u9898_u601D_u8DEF" class="headerlink" title="3、解题思路"></a>3、解题思路</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>||pHead.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="keyword">null</span>&amp;&amp;fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(slow!=<span class="keyword">null</span>&amp;&amp;fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=pHead;</span><br><span class="line">            <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">                slow=slow.next;</span><br><span class="line">                fast=fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="55_u3001_u5220_u9664_u94FE_u8868_u4E2D_u91CD_u590D_u7684_u7ED3_u70B9"><a href="#55_u3001_u5220_u9664_u94FE_u8868_u4E2D_u91CD_u590D_u7684_u7ED3_u70B9" class="headerlink" title="55、删除链表中重复的结点"></a>55、删除链表中重复的结点</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-17"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-17" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-15"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-15" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>需要定义一个指针preNode记录前一个不重复结点，然后向后查找值相同的结点，重复查找后删除，之后改指针即可。</p>
<p>需要注意头结点是否重复</p>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-14"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-14" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode preNode = <span class="keyword">null</span>;</span><br><span class="line">        ListNode node =pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next!=<span class="keyword">null</span>&amp;&amp;node.val==node.next.val)&#123;</span><br><span class="line">                <span class="keyword">int</span> val =node.val;</span><br><span class="line">                <span class="comment">//查找重复</span></span><br><span class="line">                <span class="keyword">while</span>(node.next!=<span class="keyword">null</span>&amp;&amp;node.next.val==val)&#123;</span><br><span class="line">                    node=node.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(preNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//能执行到此步说明头结点重复了</span></span><br><span class="line">                    <span class="comment">//改变pHead使其指向第一个不重复的结点</span></span><br><span class="line">                    pHead=node.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//改指针，去掉中间重复的链</span></span><br><span class="line">                    preNode.next=node.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preNode=node;<span class="comment">//头结点不重复</span></span><br><span class="line">            &#125;</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="55_u3001_u4E8C_u53C9_u6811_u7684_u4E0B_u4E00_u4E2A_u7ED3_u70B9"><a href="#55_u3001_u4E8C_u53C9_u6811_u7684_u4E0B_u4E00_u4E2A_u7ED3_u70B9" class="headerlink" title="55、二叉树的下一个结点"></a>55、二叉树的下一个结点</h2><h3 id="1_u3001_u9898_u76EE_u63CF_u8FF0-18"><a href="#1_u3001_u9898_u76EE_u63CF_u8FF0-18" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><blockquote>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 </p>
</blockquote>
<h3 id="2_u3001_u89E3_u9898_u601D_u8DEF-16"><a href="#2_u3001_u89E3_u9898_u601D_u8DEF-16" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><p>分情况讨论。中序遍历：左 -&gt; 根 -&gt; 右</p>
<p>情况一：该结点有右子树，直接进行中序遍历即可。</p>
<p>情况二：该结点无右子树，则需要访问其父节点。此时又分两种情况：</p>
<ol>
<li>若该结点是父结点的左子结点，继续访问父结点即可 </li>
<li>若是右子结点，则指针向上移动到其父结点，继续判断。 </li>
</ol>
<h3 id="3_u3001_u4EE3_u7801_u5B9E_u73B0-15"><a href="#3_u3001_u4EE3_u7801_u5B9E_u73B0-15" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right!=<span class="keyword">null</span>)&#123;<span class="comment">//该结点有右子树，进行中序遍历即可</span></span><br><span class="line">            pNode =pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                pNode=pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//若该结点无右子树，则需返回</span></span><br><span class="line">            <span class="keyword">while</span>(pNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pNode.next.left==pNode)&#123;<span class="comment">//若该节点是父节点的左孩子</span></span><br><span class="line">                    <span class="keyword">return</span> pNode.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//若是又孩子，则向上移动</span></span><br><span class="line">                    pNode = pNode.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="56_u3001_u5BF9_u79F0_u7684_u4E8C_u53C9_u6811"><a href="#56_u3001_u5BF9_u79F0_u7684_u4E8C_u53C9_u6811" class="headerlink" title="56、对称的二叉树"></a>56、对称的二叉树</h2><h3 id="u9898_u76EE_u63CF_u8FF0-35"><a href="#u9898_u76EE_u63CF_u8FF0-35" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 </p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-34"><a href="#u89E3_u9898_u601D_u8DEF-34" class="headerlink" title="解题思路"></a>解题思路</h3><p> 对左右子结点进行判断，同时由于需要<strong>镜像对称</strong>，则需将【<strong>左子结点的左子结点</strong>点和<strong>右子结点的右子结点</strong>】，【<strong>左子结点的右子节</strong>点和<strong>右子结点的左子结点</strong>】分别进行此操作进行判断，递归进行即可。 </p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-28"><a href="#u4EE3_u7801_u5B9E_u73B0-28" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSymmetricalTree(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetricalTree</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left.val == right.val </span><br><span class="line">            &amp;&amp; isSymmetricalTree(left.left,right.right)</span><br><span class="line">            &amp;&amp; isSymmetricalTree(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="57_u3001_u6309_u4E4B_u5B57_u5F62_u987A_u5E8F_u6253_u5370_u4E8C_u53C9_u6811"><a href="#57_u3001_u6309_u4E4B_u5B57_u5F62_u987A_u5E8F_u6253_u5370_u4E8C_u53C9_u6811" class="headerlink" title="57、按之字形顺序打印二叉树"></a>57、按之字形顺序打印二叉树</h2><h3 id="u9898_u76EE_u63CF_u8FF0-36"><a href="#u9898_u76EE_u63CF_u8FF0-36" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 </p>
</blockquote>
<h3 id="u89E3_u9898_u601D_u8DEF-35"><a href="#u89E3_u9898_u601D_u8DEF-35" class="headerlink" title="解题思路"></a>解题思路</h3><p> 二叉树层输出的变种。为了能够按<strong>之字形</strong>打印，则需考虑怎样能<strong>倒着输出</strong>。因此，使用<strong>两个栈</strong>来代替原来的两个队列进行广度优先搜索（BFS），即可实现。 </p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-29"><a href="#u4EE3_u7801_u5B9E_u73B0-29" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//寄奇数行</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//寄偶数行</span></span><br><span class="line">        </span><br><span class="line">        stack1.push(pRoot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty()||!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                    TreeNode node = stack1.pop();</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) stack2.push(node.left);</span><br><span class="line">                    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) stack2.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span>(!stack2.isEmpty())&#123;</span><br><span class="line">                    TreeNode node = stack2.pop();</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) stack1.push(node.right);</span><br><span class="line">                    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) stack1.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="58_u3001_u628A_u4E8C_u53C9_u6811_u6253_u5370_u6210_u591A_u884C"><a href="#58_u3001_u628A_u4E8C_u53C9_u6811_u6253_u5370_u6210_u591A_u884C" class="headerlink" title="58、把二叉树打印成多行"></a>58、把二叉树打印成多行</h2><h3 id="u9898_u76EE_u63CF_u8FF0-37"><a href="#u9898_u76EE_u63CF_u8FF0-37" class="headerlink" title="题目描述"></a>题目描述</h3><p> 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 </p>
<h3 id="u89E3_u9898_u601D_u8DEF-36"><a href="#u89E3_u9898_u601D_u8DEF-36" class="headerlink" title="解题思路"></a>解题思路</h3><p> 即二叉树层输出。使用<strong>两个队列</strong>进行广度优先搜索（BFS） </p>
<h3 id="u4EE3_u7801_u5B9E_u73B0-30"><a href="#u4EE3_u7801_u5B9E_u73B0-30" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">		ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用队列实现，不断按层压入及输出</span></span><br><span class="line">		Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		queue1.add(pRoot);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(!queue1.isEmpty() || !queue2.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!queue1.isEmpty()) &#123;</span><br><span class="line">				ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">				<span class="keyword">while</span>(!queue1.isEmpty()) &#123;</span><br><span class="line">					TreeNode node = queue1.poll();</span><br><span class="line">					list.add(node.val);</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue2.add(node.left);</span><br><span class="line">					<span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue2.add(node.right);</span><br><span class="line">				&#125;</span><br><span class="line">				result.add(list);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">				<span class="keyword">while</span>(!queue2.isEmpty()) &#123;</span><br><span class="line">					TreeNode node = queue2.poll();</span><br><span class="line">					list.add(node.val);</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue1.add(node.left);</span><br><span class="line">					<span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue1.add(node.right);</span><br><span class="line">				&#125;</span><br><span class="line">				result.add(list);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
</search>
